{"version":3,"sources":["Game/math.ts","Game/Map.ts","Game/renderer/Renderer.ts","Game/index.ts","Stage.tsx","App.tsx","serviceWorker.ts","index.tsx","Game/renderer/Resource.ts","Game/renderer/Registry.ts","Game/renderer/ViewCone.ts","Game/renderer/Tile.ts","Game/renderer/CrossSection.ts"],"names":["toPrecision","n","p","Math","round","TileMap","dict","chunksDicts","borders","chunkSizes","this","map","z","x","y","getKeyFromPosition","X13","Y13","firstPosition","getPositionFromKey","Object","keys","xMin","xMax","yMin","yMax","zMin","zMax","setChunksAndBorders","position","JSON","stringify","key","parse","chunkSize","a","b","c","chunkPosition","floor","getChunkKeyFromChunkPosition","getChunkPosition","newValue","forEach","chunksDict","i","getChunkKeyFromPosition","p1","p2","cp1","cp2","reducedP1","min","max","reducedP2","length","_crossSectionIsEmpty","focal","Renderer","canvas","tileMap","context","viewCone","framesDuration","Array","fill","lastTime","frameIndex","getContext","Error","imageSmoothingEnabled","center","w","width","h","height","nativeZoom","postRenderZoom","window","a1","a2","b1","b2","ViewCone","Date","now","renderLoop","init","console","time","discover","timeEnd","Promise","r","setTimeout","t","push","shift","log","fps","toFixed","paintCanvas","move","requestAnimationFrame","clearRect","drawImage","reduce","sum","d","Game","tile1Resource","Resource","load","tile2Resource","maskResource","Stage","canvasEl","useRef","useEffect","current","start","ref","style","border","margin","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","registry","Registry","name","url","imageJs","_isLoaded","process","addEntry","ImageJs","getCanvas","getEntry","resource","isLoaded","idFields","partialEntry","idField","entry","getId","rendererWindow","startDistanceFromCenter","zoom","crossSections","maxDistanceFromCenter","sprites","newCanvasAndContext","OffscreenCanvas","_","orderBy","crossSection","s","sprite","image","sx","sy","sw","sh","depth","distance","setImmediate","CrossSection","newCenter","newFocal","cs","buildingParams","extendedWidth","extendedHeight","recenter","MASK","Tile","type","neighborhood","tileResource","getLoadedResource","makeImageJs","above","topLeft","topRight","bottomLeft","bottomRight","under","ressourceImage","maskImage","tileImage","undefined","bitDepth","setPixelXY","maskValue","getPixelXY","FTL","FTR","FBL","FBR","LSL","LST","LSB","LSR","RSR","RST","RSB","RSL","tile","viewConeCenter","viewConeWindow","distanceFromCenter","buildingDistanceFromCenter","actualDistanceFromCenter","buildingViewConeCenter","actualViewConeCenter","actualFocal","buildingFocal","actualParams","tilesDict","spriteCropParams","isRecentering","distanceDiff","getDistanceBetween","getCrossSectionParams","getSpriteCropParams","makeTilesDict","getCrossSectionPosition","tiles","every","crossSectionPosition","point","getA","getB","cpp","getX","getY","getZ","cb","zMinBorder","zMaxBorder","extendedWindow","k","heightConstraint","ceil","k1","getHeightConstraint","k2","crossSectionConstant","crossSectionIsEmpty","getPosition","forEachTilePosition","id","getTileId","getTileAt","getOrMakeTile","newViewConeCenter","newCs","values","scale","getCrossSectionConstant"],"mappings":"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","file":"static/js/main.c4f481bd.chunk.js","sourcesContent":["export const toPrecision = (n: number, p = 3): number => {\n  return Math.round(n * 10 ** p) / 10 ** p;\n};\n","import { Position } from './interfaces';\r\nimport { toPrecision as p } from './math';\r\n\r\ninterface ChunkPosition {\r\n  a: number;\r\n  b: number;\r\n  c: number;\r\n}\r\n\r\nexport interface Borders {\r\n  xMin: number;\r\n  xMax: number;\r\n  yMin: number;\r\n  yMax: number;\r\n  zMin: number;\r\n  zMax: number;\r\n}\r\n\r\nexport class TileMap {\r\n  private dict: {\r\n    [key: string]: number;\r\n  } = {};\r\n  private chunksDicts: {\r\n    [key: string]: boolean;\r\n  }[];\r\n\r\n  public borders: Borders;\r\n  private chunkSizes = [40, 20, 10, 5];\r\n  constructor() {\r\n    // TODO load from JSON\r\n\r\n    this.chunksDicts = this.chunkSizes.map(() => ({}));\r\n\r\n    const X01 = -2;\r\n    const Y01 = -2;\r\n    const X11 = 2;\r\n    const Y11 = 2;\r\n    const Z0 = -100;\r\n    const Z1 = 0;\r\n\r\n    for (let z = Z0; z <= Z1; z++) {\r\n      for (let x = X01; x <= X11; x++) {\r\n        for (let y = Y01; y <= Y11; y++) {\r\n          this.dict[this.getKeyFromPosition({ x, y, z })] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    const X02 = -100;\r\n    const Y02 = -100;\r\n    const X12 = 100;\r\n    const Y12 = 100;\r\n    const Z2 = -103;\r\n    const Z22 = -100;\r\n\r\n    for (let z = Z2; z <= Z22; z++) {\r\n      for (let x = X02; x <= X12; x++) {\r\n        for (let y = Y02; y <= Y12; y++) {\r\n          if ((x + y) % 2 === -1) {\r\n            //continue;\r\n          }\r\n          this.dict[this.getKeyFromPosition({ x, y, z })] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    const i = 50;\r\n    const X03 = -4 + i;\r\n    const Y03 = 0 + i;\r\n    const X13 = 0 + i;\r\n    const Y13 = 4 + i;\r\n\r\n    for (let x = X03; x <= X13; x++) {\r\n      for (let y = Y03; y <= Y13; y++) {\r\n        this.dict[this.getKeyFromPosition({ x, y, z: 2 * i })] = 1;\r\n      }\r\n    }\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 1, y: Y13 + 1, z: 2 * i })] = 1;\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 3, y: Y13 + 1, z: 2 * i })] = 1;\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 1, y: Y13 + 2, z: 2 * i })] = 1;\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 3, y: Y13 + 2, z: 2 * i })] = 1;\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 2, y: Y13 + 2, z: 2 * i })] = 1;\r\n\r\n    const firstPosition = this.getPositionFromKey(Object.keys(this.dict)[0]);\r\n    this.borders = {\r\n      xMin: firstPosition.x,\r\n      xMax: firstPosition.x,\r\n      yMin: firstPosition.y,\r\n      yMax: firstPosition.y,\r\n      zMin: firstPosition.z,\r\n      zMax: firstPosition.z,\r\n    };\r\n\r\n    this.setChunksAndBorders();\r\n  }\r\n\r\n  private getKeyFromPosition(position: Position): string {\r\n    return JSON.stringify(position);\r\n  }\r\n\r\n  private getPositionFromKey(key: string): Position {\r\n    return JSON.parse(key);\r\n  }\r\n\r\n  private getChunkPosition(chunkSize: number, position: Position): ChunkPosition {\r\n    return {\r\n      a: p((position.y - position.x) / chunkSize),\r\n      b: p((position.y + position.x + position.z / 3) / chunkSize),\r\n      c: p(position.z / chunkSize),\r\n    };\r\n  }\r\n\r\n  private getChunkKeyFromChunkPosition(chunkPosition: ChunkPosition): string {\r\n    return JSON.stringify({\r\n      a: Math.floor(chunkPosition.a),\r\n      b: Math.floor(chunkPosition.b),\r\n      c: Math.floor(chunkPosition.c),\r\n    });\r\n  }\r\n\r\n  private getChunkKeyFromPosition(chunkSize: number, position: Position): string {\r\n    return this.getChunkKeyFromChunkPosition(this.getChunkPosition(chunkSize, position));\r\n  }\r\n\r\n  public getTileAt(position: Position): number {\r\n    return this.dict[this.getKeyFromPosition(position)];\r\n  }\r\n\r\n  public setTileAt(position: Position, newValue: number): void {\r\n    this.dict[this.getKeyFromPosition(position)] = newValue;\r\n  }\r\n\r\n  public removeTileAt(position: Position): void {\r\n    delete this.dict[this.getKeyFromPosition(position)];\r\n  }\r\n\r\n  public setChunksAndBorders(): void {\r\n    Object.keys(this.dict).forEach((key) => {\r\n      const position = this.getPositionFromKey(key);\r\n      if (position.x < this.borders.xMin) {\r\n        this.borders.xMin = position.x;\r\n      }\r\n      if (position.x > this.borders.xMax) {\r\n        this.borders.xMax = position.x;\r\n      }\r\n      if (position.y < this.borders.yMin) {\r\n        this.borders.yMin = position.y;\r\n      }\r\n      if (position.y > this.borders.yMax) {\r\n        this.borders.yMax = position.y;\r\n      }\r\n      if (position.z < this.borders.zMin) {\r\n        this.borders.zMin = position.z;\r\n      }\r\n      if (position.z > this.borders.zMax) {\r\n        this.borders.zMax = position.z;\r\n      }\r\n      this.chunksDicts.forEach((chunksDict, i) => {\r\n        chunksDict[this.getChunkKeyFromPosition(this.chunkSizes[i], position)] = true;\r\n      });\r\n    });\r\n  }\r\n\r\n  public _crossSectionIsEmpty(chunksDict: any, chunkSize: number, p1: Position, p2: Position): boolean {\r\n    const cp1 = this.getChunkPosition(chunkSize, p1);\r\n    const cp2 = this.getChunkPosition(chunkSize, p2);\r\n    for (let a = Math.floor(cp1.a); a <= cp2.a; a++) {\r\n      for (let c = Math.floor(cp1.c); c <= cp2.c; c++) {\r\n        if (chunksDict[this.getChunkKeyFromChunkPosition({ a, b: cp1.b, c })]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public crossSectionIsEmpty(p1: Position, p2: Position): boolean {\r\n    const reducedP1 = {\r\n      ...p1,\r\n      z: Math.min(this.borders.zMax, Math.max(this.borders.zMin, p1.z)),\r\n    };\r\n    const reducedP2 = {\r\n      ...p2,\r\n      z: Math.min(this.borders.zMax, Math.max(this.borders.zMin, p2.z)),\r\n    };\r\n    for (let i = 0; i < this.chunksDicts.length; i++) {\r\n      if (this._crossSectionIsEmpty(this.chunksDicts[i], this.chunkSizes[i], reducedP1, reducedP2) === true) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","import { TileMap } from '../Map';\nimport { Window, Position } from '../interfaces';\nimport { ViewCone } from './ViewCone';\n\nlet x = -2.1;\nlet y = -2.9;\nlet z = -0.26262;\n\nlet focal = 1000;\n\nlet i = 0.1;\n\nexport interface Sprite {\n  image: HTMLCanvasElement | HTMLImageElement | OffscreenCanvas;\n  x: number;\n  y: number;\n  scale: number;\n}\n\nexport class Renderer {\n  private context: CanvasRenderingContext2D;\n  private viewCone: ViewCone;\n\n  private framesDuration: number[] = [...Array(30)].fill(0);\n  private lastTime = 0;\n  private frameIndex = 0;\n\n  constructor(public canvas: HTMLCanvasElement, public tileMap: TileMap) {\n    const context = this.canvas.getContext('2d');\n    if (!context) {\n      throw new Error(`Context cannot be null`);\n    }\n    context.imageSmoothingEnabled = false;\n    this.context = context;\n\n    const center: Position = { x, y, z };\n    const w = this.canvas.width;\n    const h = this.canvas.height;\n    const zoom = 4;\n    const zoomQuality = 1;\n    const nativeZoom = zoom ** zoomQuality;\n    const postRenderZoom = zoom ** (1 - zoomQuality);\n    const window: Window = {\n      a1: -w / 2 / postRenderZoom,\n      a2: w / 2 / postRenderZoom,\n      b1: -h / 2 / postRenderZoom,\n      b2: h / 2 / postRenderZoom,\n    };\n\n    this.viewCone = new ViewCone(center, focal, window, -500, tileMap, nativeZoom);\n\n    this.lastTime = Date.now();\n    this.renderLoop();\n\n    this.init();\n  }\n\n  public async init() {\n    console.time('discover');\n    await this.viewCone.discover(1500);\n    console.timeEnd('discover');\n\n    await new Promise((r) => setTimeout(r, 2000));\n\n    // const p1 = { x: 1, y: -1, z: 5 };\n    // this.tileMap.setTileAt(p1, 1);\n    // this.viewCone.updateTileAt(p1);\n    // const p2 = { x: -1, y: -1, z: 0 };\n    // this.tileMap.removeTileAt(p2);\n    // this.viewCone.removeTileAt(p2);\n    // const p3 = { x: 0, y: -1, z: 0 };\n    // this.tileMap.removeTileAt(p3);\n    // this.viewCone.removeTileAt(p3);\n    // const p4 = { x: -1, y: 0, z: 0 };\n    // this.tileMap.removeTileAt(p4);\n    // this.viewCone.removeTileAt(p4);\n\n    // x += -5;\n    // y += 3;\n    // z += -6;\n    // focal *= 5;\n    // console.time('recenter');\n    // await this.viewCone.recenter({ x, y, z }, focal);\n    // console.timeEnd('recenter');\n  }\n\n  private get fps() {\n    return (this.framesDuration.length / this.framesDuration.reduce((sum, d) => sum + d, 0)) * 1000;\n  }\n\n  public renderLoop() {\n    const t = Date.now() - this.lastTime;\n    this.lastTime = Date.now();\n    this.framesDuration.push(t);\n    this.framesDuration.shift();\n\n    if (this.frameIndex++ % 30 === 0) {\n      console.log(this.fps.toFixed(1));\n    }\n\n    this.paintCanvas();\n    i += 0;\n    x += 0;\n    y += 0;\n    z -= i;\n    focal += 0;\n    if (z < -100) {\n      i = -0.1;\n    }\n    if (z > 2) {\n      i = 0.1;\n    }\n    this.viewCone.move({ x, y, z }, focal);\n    requestAnimationFrame(() => this.renderLoop());\n  }\n\n  public paintCanvas() {\n    this.viewCone.paintCanvas();\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.context.drawImage(this.viewCone.canvas, 0, 0, this.canvas.width, this.canvas.height);\n  }\n}\n","import { TileMap } from './Map';\nimport { Resource } from './renderer/Resource';\nimport { Renderer } from './renderer/Renderer';\n\nexport class Game {\n  constructor(private readonly canvas: any) {}\n\n  async start(): Promise<void> {\n    const tile1Resource = new Resource('tile1');\n    await tile1Resource.load();\n    const tile2Resource = new Resource('tile2');\n    await tile2Resource.load();\n    const maskResource = new Resource('mask');\n    await maskResource.load();\n\n    const tileMap = new TileMap();\n    const renderer = new Renderer(this.canvas, tileMap);\n  }\n}\n","import React, { useRef, useEffect } from 'react';\nimport { Game } from './Game';\n\nconst Stage = (): JSX.Element => {\n  const canvasEl = useRef(null);\n  useEffect(() => {\n    if (!canvasEl || !canvasEl.current) {\n      return;\n    }\n    const game = new Game(canvasEl.current);\n    game.start();\n  }, [canvasEl]);\n\n  return (\n    <>\n      <canvas\n        width={1600}\n        height={800}\n        ref={canvasEl}\n        style={{\n          border: '1px solid black',\n          margin: '20px',\n        }}\n      />\n    </>\n  );\n};\n\nexport default Stage;\n","import React from 'react';\nimport Stage from './Stage';\n\nconst App = (): JSX.Element => {\n  return (\n    <div>\n      <p>IME</p>\n      <Stage />\n    </div>\n  );\n};\n\nexport default App;\n","/* eslint-disable */\n\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { Image as ImageJs } from 'image-js';\nimport { Registry } from './Registry';\n\nconst registry = new Registry<Resource>(['name']);\n\nexport interface LoadedResource extends Resource {\n  imageJs: ImageJs;\n}\n\nexport class Resource {\n  private url: string;\n  public imageJs?: ImageJs;\n  public canvas?: HTMLCanvasElement;\n  private _isLoaded = false;\n  constructor(public name: string) {\n    this.url = `${process.env.PUBLIC_URL}/${name}.png`;\n\n    registry.addEntry(this);\n  }\n\n  public isLoaded(): this is LoadedResource {\n    return this._isLoaded;\n  }\n\n  public async load(): Promise<void> {\n    const imageJs: ImageJs = await ImageJs.load(this.url);\n    this.imageJs = imageJs;\n    this.canvas = this.imageJs.getCanvas();\n    this._isLoaded = true;\n  }\n\n  public static getResource(name: string): Resource | undefined {\n    return registry.getEntry({ name });\n  }\n\n  public static getLoadedResource(name: string): LoadedResource | undefined {\n    const resource = registry.getEntry({ name });\n    if (!resource || !resource.isLoaded()) {\n      return;\n    }\n    return resource;\n  }\n}\n","export class Registry<T> {\n  private dict: { [id: string]: T } = {};\n\n  constructor(public idFields: Array<keyof T>) {}\n\n  private getId(partialEntry: Partial<T>): string {\n    const key: Partial<T> = {};\n    this.idFields.forEach((idField) => {\n      key[idField] = partialEntry[idField];\n    });\n    return JSON.stringify(key);\n  }\n\n  public addEntry(entry: T): void {\n    this.dict[this.getId(entry)] = entry;\n  }\n\n  public getEntry(partialEntry: Partial<T>): T | undefined {\n    return this.dict[this.getId(partialEntry)];\n  }\n}\n","import { Window, Position } from '../interfaces';\r\nimport { CrossSection } from './CrossSection';\r\nimport { TileMap } from '../Map';\r\nimport _ from 'lodash';\r\nimport { Sprite } from './Renderer';\r\n\r\nexport class ViewCone {\r\n  public crossSections: CrossSection[] = [];\r\n  private maxDistanceFromCenter: number;\r\n  public sprites: Sprite[] = [];\r\n  public canvas: OffscreenCanvas;\r\n  public context: OffscreenCanvasRenderingContext2D;\r\n\r\n  constructor(\r\n    public center: Position,\r\n    public focal: number,\r\n    public rendererWindow: Window,\r\n    public startDistanceFromCenter: number,\r\n    public tileMap: TileMap,\r\n    public zoom: number,\r\n  ) {\r\n    this.maxDistanceFromCenter = startDistanceFromCenter - 1;\r\n\r\n    const { canvas, context } = this.newCanvasAndContext();\r\n    this.canvas = canvas;\r\n    this.context = context;\r\n  }\r\n\r\n  private newCanvasAndContext(): { canvas: OffscreenCanvas; context: OffscreenCanvasRenderingContext2D } {\r\n    const canvas = new OffscreenCanvas(this.width * this.zoom, this.height * this.zoom);\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n      throw new Error(`Context cannot be null`);\r\n    }\r\n    context.imageSmoothingEnabled = false;\r\n    return { canvas, context };\r\n  }\r\n\r\n  public paintCanvas(): void {\r\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    // TODO do not sort the cross-sections each time\r\n    const orderedCrossSections = _.orderBy(this.crossSections, ['buildingDistanceFromCenter'], ['desc']);\r\n    orderedCrossSections.forEach((crossSection) => {\r\n      const s = crossSection.sprite;\r\n      if (s) {\r\n        this.context.drawImage(s.image, s.sx, s.sy, s.sw, s.sh, 0, 0, this.canvas.width, this.canvas.height);\r\n      }\r\n    });\r\n  }\r\n\r\n  public get window(): Window {\r\n    return {\r\n      a1: this.rendererWindow.a1 / this.zoom,\r\n      a2: this.rendererWindow.a2 / this.zoom,\r\n      b1: this.rendererWindow.b1 / this.zoom,\r\n      b2: this.rendererWindow.b2 / this.zoom,\r\n    };\r\n  }\r\n\r\n  public async discover(depth: number): Promise<void> {\r\n    const maxDistanceFromCenter = this.maxDistanceFromCenter;\r\n    for (let distance = maxDistanceFromCenter + 1; distance <= maxDistanceFromCenter + depth; distance++) {\r\n      await new Promise((r) => setImmediate(r));\r\n      const crossSection = await new CrossSection(this.center, this.focal, this.window, distance, this.tileMap);\r\n      this.crossSections.push(crossSection);\r\n      this.maxDistanceFromCenter = distance - 1;\r\n    }\r\n  }\r\n\r\n  public get width(): number {\r\n    return this.window.a2 - this.window.a1;\r\n  }\r\n\r\n  public get height(): number {\r\n    return this.window.b2 - this.window.b1;\r\n  }\r\n\r\n  public move(newCenter: Position, newFocal: number): void {\r\n    let cs: CrossSection | undefined;\r\n    this.crossSections.forEach((crossSection) => {\r\n      crossSection.move(newCenter, newFocal);\r\n      if (crossSection.sprite && !cs) {\r\n        cs = crossSection;\r\n      }\r\n    });\r\n\r\n    if (!cs || !cs.sprite) {\r\n      return;\r\n    }\r\n    const p = 1 / 4;\r\n    if (\r\n      cs.sprite.sx < cs.margin.a * p ||\r\n      cs.sprite.sy < cs.margin.b * p ||\r\n      cs.sprite.sx + cs.sprite.sw > cs.buildingParams.extendedWidth - cs.margin.a * p ||\r\n      cs.sprite.sy + cs.sprite.sh > cs.buildingParams.extendedHeight - cs.margin.b * p\r\n    ) {\r\n      this.crossSections.forEach((crossSection) => {\r\n        crossSection.recenter();\r\n      });\r\n    }\r\n  }\r\n\r\n  // public async recenter(newCenter: Position, newFocal: number): Promise<void> {\r\n  //   for (let i = 0; i < this.crossSections.length; i++) {\r\n  //     await new Promise((r) => setImmediate(r));\r\n  //     const newCS = await this.crossSections[i].recenter(newCenter, newFocal);\r\n  //     this.crossSections[i] = newCS;\r\n  //   }\r\n\r\n  //   // TODO\r\n  //   // remove CS that are now too close\r\n  // }\r\n\r\n  // public updateTileAt(position: Position): void {\r\n  //   const crossSectionConstant = position.x + position.y + position.z / 3;\r\n  //   const crossSection = this.crossSections.find(\r\n  //     (cs) => Math.abs(cs.crossSectionConstant - crossSectionConstant) <= 0.001,\r\n  //   );\r\n  //   if (!crossSection) {\r\n  //     return;\r\n  //   }\r\n  //   crossSection.updatePosition(position);\r\n  // }\r\n\r\n  // public removeTileAt(position: Position): void {\r\n  //   const crossSectionConstant = position.x + position.y + position.z / 3;\r\n  //   const crossSection = this.crossSections.find((cs) => cs.crossSectionConstant === crossSectionConstant);\r\n  //   if (!crossSection) {\r\n  //     return;\r\n  //   }\r\n  //   crossSection.updatePosition(position);\r\n\r\n  //   this.updateTileAt({ ...position, z: position.z + 1 });\r\n  //   this.updateTileAt({ ...position, x: position.x + 1 });\r\n  //   this.updateTileAt({ ...position, y: position.y + 1 });\r\n  //   this.updateTileAt({ ...position, y: position.y - 1 });\r\n  //   this.updateTileAt({ ...position, x: position.x - 1 });\r\n  //   this.updateTileAt({ ...position, z: position.z - 1 });\r\n  // }\r\n}\r\n","import { Image as ImageJs } from 'image-js';\nimport { Registry } from './Registry';\nimport { Resource, LoadedResource } from './Resource';\n\nconst registry = new Registry<Tile>(['type', 'neighborhood']);\n\nconst MASK_RESOURCE_NAME = 'mask';\nenum MASK {\n  FTL = 64329,\n  LSL = 63735,\n  LSB = 10280,\n  LST = 62509,\n  FBL = 65277,\n  LSR = 57567,\n  FTR = 53199,\n  FBR = 0,\n  RSL = 59623,\n  RSB = 27296,\n  RST = 16824,\n  RSR = 61807,\n}\n\nexport interface TileNeighborhood {\n  above: boolean;\n  topLeft: boolean;\n  topRight: boolean;\n  bottomLeft: boolean;\n  bottomRight: boolean;\n  under: boolean;\n}\n\nexport class Tile {\n  public imageJs?: ImageJs;\n  public canvas?: HTMLCanvasElement;\n  private maskResource: LoadedResource;\n  private tileResource: LoadedResource;\n\n  constructor(public type: string, public neighborhood: TileNeighborhood) {\n    const tileResource = Resource.getLoadedResource(type);\n    if (!tileResource) {\n      throw new Error(`Resource '${type}' hasn't been loaded.`);\n    }\n    const maskResource = Resource.getLoadedResource(MASK_RESOURCE_NAME);\n    if (!maskResource) {\n      throw new Error(`Resource '${MASK_RESOURCE_NAME}' hasn't been loaded.`);\n    }\n    this.tileResource = tileResource;\n    this.maskResource = maskResource;\n\n    this.imageJs = this.makeImageJs();\n    this.canvas = this.imageJs?.getCanvas();\n\n    registry.addEntry(this);\n  }\n\n  public static getTile(type: string, neighborhood: TileNeighborhood): Tile | undefined {\n    return registry.getEntry({ type, neighborhood });\n  }\n\n  public static getOrMakeTile(type: string, neighborhood: TileNeighborhood): Tile {\n    const tile = registry.getEntry({ type, neighborhood });\n    if (tile) {\n      return tile;\n    }\n    return new Tile(type, neighborhood);\n  }\n\n  private makeImageJs(): ImageJs | undefined {\n    const { above, topLeft, topRight, bottomLeft, bottomRight, under } = this.neighborhood;\n    // const { above, topLeft, topRight, bottomLeft, bottomRight, under } = {\n    //   above: false,\n    //   topLeft: false,\n    //   topRight: false,\n    //   bottomLeft: false,\n    //   bottomRight: false,\n    //   under: false,\n    // };\n\n    if (above && bottomLeft && bottomRight) {\n      return;\n    }\n\n    const ressourceImage = this.tileResource.imageJs;\n    const maskImage = this.maskResource.imageJs;\n    // the TS declaration of ImageJs is incorrect: 3rd arg can (and must) be undefined\n    // eslint-disable-next-line\n    // @ts-ignore\n    const tileImage = new ImageJs(32, 24, undefined, {\n      bitDepth: 16,\n    });\n\n    for (let x = 0; x < 32; x++) {\n      for (let y = 0; y < 24; y++) {\n        tileImage.setPixelXY(x, y, [0, 0, 0, 0]);\n        const maskValue = maskImage.getPixelXY(x, y);\n        if (maskValue[0] === MASK.FTL) {\n          if (above === true) {\n            continue;\n          }\n          if (topLeft === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.FTR) {\n          if (above === true) {\n            continue;\n          }\n          if (topRight === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.FBL) {\n          if (above === true) {\n            continue;\n          }\n          if (bottomLeft === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.FBR) {\n          if (above === true) {\n            continue;\n          }\n          if (bottomRight === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.LSL) {\n          if (bottomLeft === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (topLeft === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.LST) {\n          if (bottomLeft === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (above === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.LSB) {\n          if (bottomLeft === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (under === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.LSR) {\n          if (bottomLeft === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (bottomRight === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.RSR) {\n          if (bottomRight === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (topRight === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.RST) {\n          if (bottomRight === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (above === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.RSB) {\n          if (bottomRight === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (under === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.RSL) {\n          if (bottomRight === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (bottomLeft === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n      }\n    }\n\n    return tileImage;\n  }\n}\n","import { Window, Position, CrossSectionPosition } from '../interfaces';\r\nimport { TileMap } from '../Map';\r\nimport { Tile, TileNeighborhood } from './Tile';\r\n\r\nexport interface SpriteCropParams {\r\n  sx: number;\r\n  sy: number;\r\n  sw: number;\r\n  sh: number;\r\n}\r\n\r\nexport interface Sprite {\r\n  image: OffscreenCanvas;\r\n  sx: number;\r\n  sy: number;\r\n  sw: number;\r\n  sh: number;\r\n}\r\n\r\nexport interface PositionedTile {\r\n  position: Position;\r\n  crossSectionPosition: CrossSectionPosition;\r\n  tile: Tile;\r\n}\r\n\r\nexport interface TilesDict {\r\n  [key: string]: PositionedTile;\r\n}\r\n\r\nexport interface CrossSectionParams {\r\n  center: Position;\r\n  scale: number;\r\n  window: Window;\r\n  width: number;\r\n  height: number;\r\n  extendedWindow: Window;\r\n  extendedWidth: number;\r\n  extendedHeight: number;\r\n  heightConstraint: number;\r\n  crossSectionConstant: number;\r\n}\r\n\r\nexport class CrossSection {\r\n  public buildingDistanceFromCenter: number;\r\n  public actualDistanceFromCenter: number;\r\n  public buildingViewConeCenter: Position;\r\n  public actualViewConeCenter: Position;\r\n  public actualFocal: number;\r\n  public buildingFocal: number;\r\n  private actualParams: CrossSectionParams;\r\n  public buildingParams: CrossSectionParams;\r\n  private tilesDict: TilesDict;\r\n  private canvas?: OffscreenCanvas;\r\n  private context?: OffscreenCanvasRenderingContext2D;\r\n  private spriteCropParams: SpriteCropParams;\r\n  public isRecentering = false;\r\n\r\n  constructor(\r\n    viewConeCenter: Position,\r\n    public focal: number,\r\n    public viewConeWindow: Window,\r\n    distanceFromCenter: number,\r\n    public tileMap: TileMap,\r\n    public margin: CrossSectionPosition = { a: 96, b: 48 },\r\n  ) {\r\n    this.buildingViewConeCenter = {\r\n      x: Math.round(viewConeCenter.x),\r\n      y: Math.round(viewConeCenter.y),\r\n      z: Math.round(viewConeCenter.z),\r\n    };\r\n    this.actualViewConeCenter = viewConeCenter;\r\n\r\n    const distanceDiff = CrossSection.getDistanceBetween(this.buildingViewConeCenter, viewConeCenter);\r\n    this.buildingDistanceFromCenter = Math.round(distanceFromCenter + distanceDiff);\r\n    this.actualDistanceFromCenter = Math.round(distanceFromCenter);\r\n\r\n    this.actualFocal = focal;\r\n    this.buildingFocal = focal;\r\n\r\n    this.actualParams = CrossSection.getCrossSectionParams(\r\n      this.actualViewConeCenter,\r\n      focal,\r\n      viewConeWindow,\r\n      this.actualDistanceFromCenter,\r\n      margin,\r\n    );\r\n\r\n    this.buildingParams = CrossSection.getCrossSectionParams(\r\n      this.buildingViewConeCenter,\r\n      focal,\r\n      viewConeWindow,\r\n      this.buildingDistanceFromCenter,\r\n      margin,\r\n    );\r\n\r\n    this.spriteCropParams = this.getSpriteCropParams();\r\n\r\n    this.tilesDict = this.makeTilesDict();\r\n    this.paintCanvas();\r\n  }\r\n\r\n  private getSpriteCropParams(): SpriteCropParams {\r\n    const { a, b } = this.getCrossSectionPosition(this.actualParams.center);\r\n\r\n    return {\r\n      sx: this.margin.a + a + Math.round(this.buildingParams.extendedWidth / 2) - this.actualParams.extendedWidth / 2,\r\n      sy: this.margin.b - b + Math.round(this.buildingParams.extendedHeight / 2) - this.actualParams.extendedHeight / 2,\r\n      sw: this.actualParams.width,\r\n      sh: this.actualParams.height,\r\n    };\r\n  }\r\n\r\n  public static getCrossSectionParams(\r\n    viewConeCenter: Position,\r\n    focal: number,\r\n    viewConeWindow: Window,\r\n    distanceFromCenter: number,\r\n    margin: CrossSectionPosition,\r\n  ): CrossSectionParams {\r\n    const center = {\r\n      x: viewConeCenter.x - distanceFromCenter / 8,\r\n      y: viewConeCenter.y - distanceFromCenter / 8,\r\n      z: viewConeCenter.z - distanceFromCenter / 4,\r\n    };\r\n\r\n    const scale = 1 + distanceFromCenter / focal;\r\n\r\n    const window = {\r\n      a1: viewConeWindow.a1 * scale,\r\n      a2: viewConeWindow.a2 * scale,\r\n      b1: viewConeWindow.b1 * scale,\r\n      b2: viewConeWindow.b2 * scale,\r\n    };\r\n\r\n    const width = window.a2 - window.a1;\r\n    const height = window.b2 - window.b1;\r\n\r\n    const extendedWindow = {\r\n      a1: window.a1 - margin.a,\r\n      a2: window.a2 + margin.a,\r\n      b1: window.b1 - margin.b,\r\n      b2: window.b2 + margin.b,\r\n    };\r\n\r\n    const extendedWidth = extendedWindow.a2 - extendedWindow.a1;\r\n    const extendedHeight = extendedWindow.b2 - extendedWindow.b1;\r\n\r\n    const heightConstraint = CrossSection.getHeightConstraint(viewConeCenter.z - distanceFromCenter);\r\n\r\n    const crossSectionConstant = CrossSection.getCrossSectionConstant(center);\r\n\r\n    return {\r\n      center,\r\n      scale,\r\n      window,\r\n      width,\r\n      height,\r\n      extendedWindow,\r\n      extendedWidth,\r\n      extendedHeight,\r\n      heightConstraint,\r\n      crossSectionConstant,\r\n    };\r\n  }\r\n\r\n  public static getCrossSectionConstant(position: Position): number {\r\n    return position.x + position.y + position.z / 3;\r\n  }\r\n\r\n  public static getDistanceBetween(p1: Position, p2: Position): number {\r\n    const k1 = CrossSection.getCrossSectionConstant(p1);\r\n    const k2 = CrossSection.getCrossSectionConstant(p2);\r\n    return 3 * (k1 - k2);\r\n  }\r\n\r\n  public get sprite(): Sprite | undefined {\r\n    if (!this.canvas) {\r\n      return;\r\n    }\r\n    const { sx, sy, sw, sh } = this.spriteCropParams;\r\n    return {\r\n      image: this.canvas,\r\n      sx,\r\n      sy,\r\n      sw,\r\n      sh,\r\n    };\r\n  }\r\n\r\n  private newCanvasAndContext(): { canvas: OffscreenCanvas; context: OffscreenCanvasRenderingContext2D } {\r\n    const canvas = new OffscreenCanvas(this.buildingParams.extendedWidth, this.buildingParams.extendedHeight);\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n      throw new Error(`Context cannot be null`);\r\n    }\r\n    context.imageSmoothingEnabled = false;\r\n    return { canvas, context };\r\n  }\r\n\r\n  public paintCanvas(): void {\r\n    const tiles = this.tiles;\r\n    if (tiles.length === 0 || tiles.every(({ tile }) => !tile.canvas)) {\r\n      if (this.context) {\r\n        delete this.context;\r\n        delete this.canvas;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (!this.context) {\r\n      const { canvas, context } = this.newCanvasAndContext();\r\n      this.canvas = canvas;\r\n      this.context = context;\r\n    }\r\n\r\n    this.context.clearRect(0, 0, this.buildingParams.extendedWidth, this.buildingParams.extendedHeight);\r\n    //this.context.globalAlpha = 0.3;\r\n    tiles.forEach(({ crossSectionPosition: { a, b }, tile }) => {\r\n      if (!tile.canvas || !this.context) {\r\n        return;\r\n      }\r\n      this.context.drawImage(\r\n        tile.canvas,\r\n        Math.round(this.buildingParams.extendedWidth / 2) + (a - 16),\r\n        Math.round(this.buildingParams.extendedHeight / 2) + (-b - 8),\r\n        tile.canvas.width,\r\n        tile.canvas.height,\r\n      );\r\n    });\r\n  }\r\n\r\n  public static getHeightConstraint(z: number): number {\r\n    return (3 + (z % 3)) % 3;\r\n  }\r\n\r\n  public getA({ x, y }: { x: number; y: number }): number {\r\n    return 16 * (y - this.buildingParams.center.y - (x - this.buildingParams.center.x));\r\n  }\r\n  public getB({ z }: { z: number }): number {\r\n    return (32 / 3) * (z - this.buildingParams.center.z);\r\n  }\r\n\r\n  public getCrossSectionPosition(point: Position): CrossSectionPosition {\r\n    return {\r\n      a: this.getA(point),\r\n      b: this.getB(point),\r\n    };\r\n  }\r\n\r\n  public getX({ a, b }: CrossSectionPosition): number {\r\n    return this.buildingParams.center.x - a / 32 - b / 64;\r\n  }\r\n  public getY({ a, b }: CrossSectionPosition): number {\r\n    return this.buildingParams.center.y + a / 32 - b / 64;\r\n  }\r\n  public getZ({ b }: { b: number }): number {\r\n    return this.buildingParams.center.z + (3 * b) / 32;\r\n  }\r\n\r\n  public getPosition(cpp: CrossSectionPosition): Position {\r\n    return {\r\n      x: this.getX(cpp),\r\n      y: this.getY(cpp),\r\n      z: this.getZ(cpp),\r\n    };\r\n  }\r\n\r\n  public forEachTilePosition(cb: (position: Position) => void, zMinBorder?: number, zMaxBorder?: number): void {\r\n    const { a1, a2, b1, b2 } = this.buildingParams.extendedWindow;\r\n\r\n    const k = this.buildingParams.heightConstraint;\r\n\r\n    // first integer z in the area\r\n    let zMin = Math.ceil(this.getZ({ b: b1 }));\r\n    if (zMinBorder && zMinBorder > zMin) {\r\n      zMin = zMinBorder;\r\n    }\r\n    // first multiple of ki after zMin\r\n    const k1 = CrossSection.getHeightConstraint(zMin);\r\n    if (k1 !== k) {\r\n      zMin = zMin + CrossSection.getHeightConstraint(k - k1);\r\n    }\r\n\r\n    // last integer z in the area\r\n    let zMax = Math.floor(this.getZ({ b: b2 }));\r\n    if (zMaxBorder && zMaxBorder < zMax) {\r\n      zMax = zMaxBorder;\r\n    }\r\n    // last multiple of ki before zMax\r\n    const k2 = CrossSection.getHeightConstraint(zMax);\r\n    if (k2 !== k) {\r\n      zMax = zMax - CrossSection.getHeightConstraint(-k + k2);\r\n    }\r\n\r\n    for (let z = zMin; z <= zMax; z += 3) {\r\n      const b = this.getB({ z });\r\n      // first integer y in the line z of the area\r\n      const yMin = Math.ceil(this.getY({ a: a1, b }));\r\n      // last integer y in the line z of the area\r\n      const yMax = Math.floor(this.getY({ a: a2, b }));\r\n      for (let y = yMin; y <= yMax; y++) {\r\n        const x = Math.round(this.buildingParams.crossSectionConstant - y - z / 3);\r\n        cb({ x, y, z });\r\n      }\r\n    }\r\n  }\r\n\r\n  public get tiles(): PositionedTile[] {\r\n    return Object.values(this.tilesDict);\r\n  }\r\n\r\n  public static getTileId(position: Position): string {\r\n    return JSON.stringify(position);\r\n  }\r\n\r\n  public makeTilesDict(): TilesDict {\r\n    const tilesDict: TilesDict = {};\r\n    const tileMap = this.tileMap;\r\n\r\n    // check if it may be useless to do anything\r\n    const { a1, a2, b1, b2 } = this.buildingParams.extendedWindow;\r\n    if (tileMap.crossSectionIsEmpty(this.getPosition({ a: a1, b: b1 }), this.getPosition({ a: a2, b: b2 }))) {\r\n      return tilesDict;\r\n    }\r\n\r\n    this.forEachTilePosition(\r\n      (position) => {\r\n        const id = CrossSection.getTileId(position);\r\n        const value = tileMap.getTileAt(position);\r\n        if (value) {\r\n          const neighborhood: TileNeighborhood = {\r\n            above: tileMap.getTileAt({ ...position, z: position.z + 1 }) === 1,\r\n            bottomLeft: tileMap.getTileAt({ ...position, x: position.x + 1 }) === 1,\r\n            bottomRight: tileMap.getTileAt({ ...position, y: position.y + 1 }) === 1,\r\n            topLeft: tileMap.getTileAt({ ...position, y: position.y - 1 }) === 1,\r\n            topRight: tileMap.getTileAt({ ...position, x: position.x - 1 }) === 1,\r\n            under: tileMap.getTileAt({ ...position, z: position.z - 1 }) === 1,\r\n          };\r\n          const tile = Tile.getOrMakeTile('tile2', neighborhood);\r\n          tilesDict[id] = {\r\n            position,\r\n            crossSectionPosition: this.getCrossSectionPosition(position),\r\n            tile,\r\n          };\r\n        }\r\n      },\r\n      tileMap.borders.zMin,\r\n      tileMap.borders.zMax,\r\n    );\r\n\r\n    return tilesDict;\r\n  }\r\n\r\n  public move(newViewConeCenter: Position, newFocal: number): void {\r\n    const distanceDiff = CrossSection.getDistanceBetween(newViewConeCenter, this.actualViewConeCenter);\r\n    this.actualDistanceFromCenter += distanceDiff;\r\n    this.actualViewConeCenter = newViewConeCenter;\r\n    this.actualFocal = newFocal;\r\n    this.actualParams = CrossSection.getCrossSectionParams(\r\n      newViewConeCenter,\r\n      newFocal,\r\n      this.viewConeWindow,\r\n      this.actualDistanceFromCenter,\r\n      this.margin,\r\n    );\r\n\r\n    this.spriteCropParams = this.getSpriteCropParams();\r\n\r\n    const { sx, sy, sw, sh } = this.spriteCropParams;\r\n\r\n    const p = 3 / 4;\r\n    if (\r\n      sx < this.margin.a * p ||\r\n      sy < this.margin.b * p ||\r\n      sx + sw > this.buildingParams.extendedWidth - this.margin.a * p ||\r\n      sy + sh > this.buildingParams.extendedHeight - this.margin.b * p\r\n    ) {\r\n      // this.recenter();\r\n    }\r\n  }\r\n\r\n  public recenter() {\r\n    if (this.isRecentering) {\r\n      return;\r\n    }\r\n    this.isRecentering = true;\r\n    //await new Promise((r) => setImmediate(r));\r\n    const newCs = new CrossSection(\r\n      this.actualViewConeCenter,\r\n      this.actualFocal,\r\n      this.viewConeWindow,\r\n      this.actualDistanceFromCenter,\r\n      this.tileMap,\r\n      this.margin,\r\n    );\r\n    this.buildingViewConeCenter = newCs.buildingViewConeCenter;\r\n    this.buildingDistanceFromCenter = newCs.buildingDistanceFromCenter;\r\n    this.buildingParams = newCs.buildingParams;\r\n    this.buildingFocal = newCs.buildingFocal;\r\n    this.spriteCropParams = newCs.spriteCropParams;\r\n    this.tilesDict = newCs.tilesDict;\r\n    this.canvas = newCs.canvas;\r\n    this.context = newCs.context;\r\n    this.isRecentering = false;\r\n  }\r\n\r\n  // public recenter(newViewConeCenter: Position, newFocal: number): CrossSection {\r\n  //   const k2 = newViewConeCenter.x + newViewConeCenter.y + newViewConeCenter.z / 3;\r\n  //   const k1 = this.viewConeCenter.x + this.viewConeCenter.y + this.viewConeCenter.z / 3;\r\n  //   const distanceDiff = 3 * (k2 - k1);\r\n  //   const newDistanceFromCenter = this.distanceFromCenter + distanceDiff;\r\n\r\n  //   // TODO\r\n  //   // instead of doing 1 new, do up to 4 smaller without margin and merge them into the current one\r\n\r\n  //   const newCs = new CrossSection(\r\n  //     newViewConeCenter,\r\n  //     newFocal,\r\n  //     this.viewConeWindow,\r\n  //     newDistanceFromCenter,\r\n  //     this.tileMap,\r\n  //     this.margin,\r\n  //     this.tilesDict,\r\n  //   );\r\n  //   return newCs;\r\n  // }\r\n\r\n  // public updatePosition(position: Position): void {\r\n  //   const tileMap = this.tileMap;\r\n  //   const value = tileMap.getTileAt(position);\r\n  //   const id = CrossSection.getTileId(position);\r\n  //   if (!value) {\r\n  //     delete this.tilesDict[id];\r\n  //     return;\r\n  //   }\r\n  //   const neighborhood: TileNeighborhood = {\r\n  //     above: tileMap.getTileAt({ ...position, z: position.z + 1 }) === 1,\r\n  //     bottomLeft: tileMap.getTileAt({ ...position, x: position.x + 1 }) === 1,\r\n  //     bottomRight: tileMap.getTileAt({ ...position, y: position.y + 1 }) === 1,\r\n  //     topLeft: tileMap.getTileAt({ ...position, y: position.y - 1 }) === 1,\r\n  //     topRight: tileMap.getTileAt({ ...position, x: position.x - 1 }) === 1,\r\n  //     under: tileMap.getTileAt({ ...position, z: position.z - 1 }) === 1,\r\n  //   };\r\n  //   const tile = Tile.getOrMakeTile('tile2', neighborhood);\r\n  //   this.tilesDict[id] = {\r\n  //     position,\r\n  //     crossSectionPosition: this.getCrossSectionPosition(position),\r\n  //     tile,\r\n  //   };\r\n  // }\r\n}\r\n"],"sourceRoot":""}