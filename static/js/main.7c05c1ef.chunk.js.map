{"version":3,"sources":["Game/math.ts","Game/Map.ts","Game/renderer/Renderer.ts","Game/index.ts","Stage.tsx","App.tsx","serviceWorker.ts","index.tsx","Game/renderer/Resource.ts","Game/renderer/Registry.ts","Game/renderer/ViewCone.ts","Game/renderer/Tile.ts","Game/renderer/CrossSection.ts"],"names":["toPrecision","n","p","Math","round","TileMap","dict","chunksDicts","borders","chunkSizes","this","map","z","x","y","getKeyFromPosition","X13","Y13","firstPosition","getPositionFromKey","Object","keys","xMin","xMax","yMin","yMax","zMin","zMax","setChunksAndBorders","position","JSON","stringify","key","parse","chunkSize","a","b","c","chunkPosition","floor","getChunkKeyFromChunkPosition","getChunkPosition","newValue","forEach","chunksDict","i","getChunkKeyFromPosition","p1","p2","cp1","cp2","reducedP1","min","max","reducedP2","length","_crossSectionIsEmpty","focal","Renderer","canvas","tileMap","context","viewCone","framesDuration","Array","fill","lastTime","frameIndex","getContext","Error","imageSmoothingEnabled","center","w","width","h","height","nativeZoom","postRenderZoom","window","a1","a2","b1","b2","ViewCone","Date","now","renderLoop","init","console","time","discover","timeEnd","Promise","r","setTimeout","t","push","shift","log","fps","toFixed","paintCanvas","move","requestAnimationFrame","clearRect","drawImage","reduce","sum","d","Game","tile1Resource","Resource","load","tile2Resource","maskResource","Stage","canvasEl","useRef","useEffect","current","start","ref","style","border","margin","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","registry","Registry","name","url","imageJs","_isLoaded","process","addEntry","ImageJs","getCanvas","getEntry","resource","isLoaded","idFields","partialEntry","idField","entry","getId","rendererWindow","startDistanceFromCenter","zoom","crossSections","maxDistanceFromCenter","sprites","recentering","newCanvasAndContext","OffscreenCanvas","_","orderBy","crossSection","s","sprite","image","sx","sy","sw","sh","depth","workFor","distance","setImmediate","CrossSection","newCenter","newFocal","cs","buildingParams","extendedWidth","extendedHeight","recenter","e","MASK","Tile","type","neighborhood","tileResource","getLoadedResource","makeImageJs","above","topLeft","topRight","bottomLeft","bottomRight","under","ressourceImage","maskImage","tileImage","undefined","bitDepth","setPixelXY","maskValue","getPixelXY","FTL","FTR","FBL","FBR","LSL","LST","LSB","LSR","RSR","RST","RSB","RSL","tile","viewConeCenter","viewConeWindow","distanceFromCenter","buildingDistanceFromCenter","actualDistanceFromCenter","buildingViewConeCenter","actualViewConeCenter","actualFocal","buildingFocal","actualParams","tilesDict","spriteCropParams","isRecentering","distanceDiff","getDistanceBetween","getCrossSectionParams","getSpriteCropParams","makeTilesDict","getCrossSectionPosition","tiles","every","crossSectionPosition","point","getA","getB","cpp","getX","getY","getZ","cb","zMinBorder","zMaxBorder","extendedWindow","k","heightConstraint","ceil","k1","getHeightConstraint","k2","crossSectionConstant","crossSectionIsEmpty","getPosition","forEachTilePosition","id","getTileId","getTileAt","getOrMakeTile","newViewConeCenter","newCs","values","scale","getCrossSectionConstant"],"mappings":"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","file":"static/js/main.7c05c1ef.chunk.js","sourcesContent":["export const toPrecision = (n: number, p = 3): number => {\n  return Math.round(n * 10 ** p) / 10 ** p;\n};\n","import { Position } from './interfaces';\r\nimport { toPrecision as p } from './math';\r\n\r\ninterface ChunkPosition {\r\n  a: number;\r\n  b: number;\r\n  c: number;\r\n}\r\n\r\nexport interface Borders {\r\n  xMin: number;\r\n  xMax: number;\r\n  yMin: number;\r\n  yMax: number;\r\n  zMin: number;\r\n  zMax: number;\r\n}\r\n\r\nexport class TileMap {\r\n  private dict: {\r\n    [key: string]: number;\r\n  } = {};\r\n  private chunksDicts: {\r\n    [key: string]: boolean;\r\n  }[];\r\n\r\n  public borders: Borders;\r\n  private chunkSizes = [40, 20, 10, 5];\r\n  constructor() {\r\n    // TODO load from JSON\r\n\r\n    this.chunksDicts = this.chunkSizes.map(() => ({}));\r\n\r\n    const X01 = -2;\r\n    const Y01 = -2;\r\n    const X11 = 2;\r\n    const Y11 = 2;\r\n    const Z0 = -100;\r\n    const Z1 = 0;\r\n\r\n    for (let z = Z0; z <= Z1; z++) {\r\n      for (let x = X01; x <= X11; x++) {\r\n        for (let y = Y01; y <= Y11; y++) {\r\n          this.dict[this.getKeyFromPosition({ x, y, z })] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    const X02 = -100;\r\n    const Y02 = -100;\r\n    const X12 = 100;\r\n    const Y12 = 100;\r\n    const Z2 = -103;\r\n    const Z22 = -100;\r\n\r\n    for (let z = Z2; z <= Z22; z++) {\r\n      for (let x = X02; x <= X12; x++) {\r\n        for (let y = Y02; y <= Y12; y++) {\r\n          if ((x + y) % 2 === -1) {\r\n            //continue;\r\n          }\r\n          this.dict[this.getKeyFromPosition({ x, y, z })] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    const i = 50;\r\n    const X03 = -4 + i;\r\n    const Y03 = 0 + i;\r\n    const X13 = 0 + i;\r\n    const Y13 = 4 + i;\r\n\r\n    for (let x = X03; x <= X13; x++) {\r\n      for (let y = Y03; y <= Y13; y++) {\r\n        this.dict[this.getKeyFromPosition({ x, y, z: 2 * i })] = 1;\r\n      }\r\n    }\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 1, y: Y13 + 1, z: 2 * i })] = 1;\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 3, y: Y13 + 1, z: 2 * i })] = 1;\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 1, y: Y13 + 2, z: 2 * i })] = 1;\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 3, y: Y13 + 2, z: 2 * i })] = 1;\r\n    this.dict[this.getKeyFromPosition({ x: X13 - 2, y: Y13 + 2, z: 2 * i })] = 1;\r\n\r\n    const firstPosition = this.getPositionFromKey(Object.keys(this.dict)[0]);\r\n    this.borders = {\r\n      xMin: firstPosition.x,\r\n      xMax: firstPosition.x,\r\n      yMin: firstPosition.y,\r\n      yMax: firstPosition.y,\r\n      zMin: firstPosition.z,\r\n      zMax: firstPosition.z,\r\n    };\r\n\r\n    this.setChunksAndBorders();\r\n  }\r\n\r\n  private getKeyFromPosition(position: Position): string {\r\n    return JSON.stringify(position);\r\n  }\r\n\r\n  private getPositionFromKey(key: string): Position {\r\n    return JSON.parse(key);\r\n  }\r\n\r\n  private getChunkPosition(chunkSize: number, position: Position): ChunkPosition {\r\n    return {\r\n      a: p((position.y - position.x) / chunkSize),\r\n      b: p((position.y + position.x + position.z / 3) / chunkSize),\r\n      c: p(position.z / chunkSize),\r\n    };\r\n  }\r\n\r\n  private getChunkKeyFromChunkPosition(chunkPosition: ChunkPosition): string {\r\n    return JSON.stringify({\r\n      a: Math.floor(chunkPosition.a),\r\n      b: Math.floor(chunkPosition.b),\r\n      c: Math.floor(chunkPosition.c),\r\n    });\r\n  }\r\n\r\n  private getChunkKeyFromPosition(chunkSize: number, position: Position): string {\r\n    return this.getChunkKeyFromChunkPosition(this.getChunkPosition(chunkSize, position));\r\n  }\r\n\r\n  public getTileAt(position: Position): number {\r\n    return this.dict[this.getKeyFromPosition(position)];\r\n  }\r\n\r\n  public setTileAt(position: Position, newValue: number): void {\r\n    this.dict[this.getKeyFromPosition(position)] = newValue;\r\n  }\r\n\r\n  public removeTileAt(position: Position): void {\r\n    delete this.dict[this.getKeyFromPosition(position)];\r\n  }\r\n\r\n  public setChunksAndBorders(): void {\r\n    Object.keys(this.dict).forEach((key) => {\r\n      const position = this.getPositionFromKey(key);\r\n      if (position.x < this.borders.xMin) {\r\n        this.borders.xMin = position.x;\r\n      }\r\n      if (position.x > this.borders.xMax) {\r\n        this.borders.xMax = position.x;\r\n      }\r\n      if (position.y < this.borders.yMin) {\r\n        this.borders.yMin = position.y;\r\n      }\r\n      if (position.y > this.borders.yMax) {\r\n        this.borders.yMax = position.y;\r\n      }\r\n      if (position.z < this.borders.zMin) {\r\n        this.borders.zMin = position.z;\r\n      }\r\n      if (position.z > this.borders.zMax) {\r\n        this.borders.zMax = position.z;\r\n      }\r\n      this.chunksDicts.forEach((chunksDict, i) => {\r\n        chunksDict[this.getChunkKeyFromPosition(this.chunkSizes[i], position)] = true;\r\n      });\r\n    });\r\n  }\r\n\r\n  public _crossSectionIsEmpty(chunksDict: any, chunkSize: number, p1: Position, p2: Position): boolean {\r\n    const cp1 = this.getChunkPosition(chunkSize, p1);\r\n    const cp2 = this.getChunkPosition(chunkSize, p2);\r\n    for (let a = Math.floor(cp1.a); a <= cp2.a; a++) {\r\n      for (let c = Math.floor(cp1.c); c <= cp2.c; c++) {\r\n        if (chunksDict[this.getChunkKeyFromChunkPosition({ a, b: cp1.b, c })]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public crossSectionIsEmpty(p1: Position, p2: Position): boolean {\r\n    const reducedP1 = {\r\n      ...p1,\r\n      z: Math.min(this.borders.zMax, Math.max(this.borders.zMin, p1.z)),\r\n    };\r\n    const reducedP2 = {\r\n      ...p2,\r\n      z: Math.min(this.borders.zMax, Math.max(this.borders.zMin, p2.z)),\r\n    };\r\n    for (let i = 0; i < this.chunksDicts.length; i++) {\r\n      if (this._crossSectionIsEmpty(this.chunksDicts[i], this.chunkSizes[i], reducedP1, reducedP2) === true) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","import { TileMap } from '../Map';\r\nimport { Window, Position } from '../interfaces';\r\nimport { ViewCone } from './ViewCone';\r\n\r\nlet x = -2.1;\r\nlet y = -2.9;\r\nlet z = -0.26262;\r\n\r\nlet focal = 1000;\r\n\r\nlet i = 0.05;\r\n\r\nexport interface Sprite {\r\n  image: HTMLCanvasElement | HTMLImageElement | OffscreenCanvas;\r\n  x: number;\r\n  y: number;\r\n  scale: number;\r\n}\r\n\r\nexport class Renderer {\r\n  private context: CanvasRenderingContext2D;\r\n  private viewCone: ViewCone;\r\n\r\n  private framesDuration: number[] = [...Array(30)].fill(0);\r\n  private lastTime = 0;\r\n  private frameIndex = 0;\r\n\r\n  constructor(public canvas: HTMLCanvasElement, public tileMap: TileMap) {\r\n    const context = this.canvas.getContext('2d');\r\n    if (!context) {\r\n      throw new Error(`Context cannot be null`);\r\n    }\r\n    context.imageSmoothingEnabled = false;\r\n    this.context = context;\r\n\r\n    const center: Position = { x, y, z };\r\n    const w = this.canvas.width;\r\n    const h = this.canvas.height;\r\n    const zoom = 4;\r\n    const zoomQuality = 1;\r\n    const nativeZoom = zoom ** zoomQuality;\r\n    const postRenderZoom = zoom ** (1 - zoomQuality);\r\n    const window: Window = {\r\n      a1: -w / 2 / postRenderZoom,\r\n      a2: w / 2 / postRenderZoom,\r\n      b1: -h / 2 / postRenderZoom,\r\n      b2: h / 2 / postRenderZoom,\r\n    };\r\n\r\n    this.viewCone = new ViewCone(center, focal, window, -500, tileMap, nativeZoom);\r\n\r\n    this.lastTime = Date.now();\r\n    this.renderLoop();\r\n\r\n    this.init();\r\n  }\r\n\r\n  public async init() {\r\n    console.time('discover');\r\n    await this.viewCone.discover(1500);\r\n    console.timeEnd('discover');\r\n\r\n    await new Promise((r) => setTimeout(r, 2000));\r\n\r\n    // const p1 = { x: 1, y: -1, z: 5 };\r\n    // this.tileMap.setTileAt(p1, 1);\r\n    // this.viewCone.updateTileAt(p1);\r\n    // const p2 = { x: -1, y: -1, z: 0 };\r\n    // this.tileMap.removeTileAt(p2);\r\n    // this.viewCone.removeTileAt(p2);\r\n    // const p3 = { x: 0, y: -1, z: 0 };\r\n    // this.tileMap.removeTileAt(p3);\r\n    // this.viewCone.removeTileAt(p3);\r\n    // const p4 = { x: -1, y: 0, z: 0 };\r\n    // this.tileMap.removeTileAt(p4);\r\n    // this.viewCone.removeTileAt(p4);\r\n\r\n    // x += -5;\r\n    // y += 3;\r\n    // z += -6;\r\n    // focal *= 5;\r\n    // console.time('recenter');\r\n    // await this.viewCone.recenter({ x, y, z }, focal);\r\n    // console.timeEnd('recenter');\r\n  }\r\n\r\n  private get fps() {\r\n    return (this.framesDuration.length / this.framesDuration.reduce((sum, d) => sum + d, 0)) * 1000;\r\n  }\r\n\r\n  public renderLoop() {\r\n    const t = Date.now() - this.lastTime;\r\n    this.lastTime = Date.now();\r\n    this.framesDuration.push(t);\r\n    this.framesDuration.shift();\r\n\r\n    if (this.frameIndex++ % 30 === 0) {\r\n      console.log(this.fps.toFixed(1));\r\n    }\r\n\r\n    this.paintCanvas();\r\n    i += 0;\r\n    x += i;\r\n    y += i;\r\n    z -= i;\r\n    focal += 0;\r\n    if (z < -100) {\r\n      i = -0.1;\r\n    }\r\n    if (z > 2) {\r\n      i = 0.1;\r\n    }\r\n    this.viewCone.move({ x, y, z }, focal);\r\n    requestAnimationFrame(() => this.renderLoop());\r\n  }\r\n\r\n  public paintCanvas() {\r\n    this.viewCone.paintCanvas();\r\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.context.drawImage(this.viewCone.canvas, 0, 0, this.canvas.width, this.canvas.height);\r\n  }\r\n}\r\n","import { TileMap } from './Map';\nimport { Resource } from './renderer/Resource';\nimport { Renderer } from './renderer/Renderer';\n\nexport class Game {\n  constructor(private readonly canvas: any) {}\n\n  async start(): Promise<void> {\n    const tile1Resource = new Resource('tile1');\n    await tile1Resource.load();\n    const tile2Resource = new Resource('tile2');\n    await tile2Resource.load();\n    const maskResource = new Resource('mask');\n    await maskResource.load();\n\n    const tileMap = new TileMap();\n    const renderer = new Renderer(this.canvas, tileMap);\n  }\n}\n","import React, { useRef, useEffect } from 'react';\nimport { Game } from './Game';\n\nconst Stage = (): JSX.Element => {\n  const canvasEl = useRef(null);\n  useEffect(() => {\n    if (!canvasEl || !canvasEl.current) {\n      return;\n    }\n    const game = new Game(canvasEl.current);\n    game.start();\n  }, [canvasEl]);\n\n  return (\n    <>\n      <canvas\n        width={1600}\n        height={800}\n        ref={canvasEl}\n        style={{\n          border: '1px solid black',\n          margin: '20px',\n        }}\n      />\n    </>\n  );\n};\n\nexport default Stage;\n","import React from 'react';\nimport Stage from './Stage';\n\nconst App = (): JSX.Element => {\n  return (\n    <div>\n      <p>IME</p>\n      <Stage />\n    </div>\n  );\n};\n\nexport default App;\n","/* eslint-disable */\n\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { Image as ImageJs } from 'image-js';\nimport { Registry } from './Registry';\n\nconst registry = new Registry<Resource>(['name']);\n\nexport interface LoadedResource extends Resource {\n  imageJs: ImageJs;\n}\n\nexport class Resource {\n  private url: string;\n  public imageJs?: ImageJs;\n  public canvas?: HTMLCanvasElement;\n  private _isLoaded = false;\n  constructor(public name: string) {\n    this.url = `${process.env.PUBLIC_URL}/${name}.png`;\n\n    registry.addEntry(this);\n  }\n\n  public isLoaded(): this is LoadedResource {\n    return this._isLoaded;\n  }\n\n  public async load(): Promise<void> {\n    const imageJs: ImageJs = await ImageJs.load(this.url);\n    this.imageJs = imageJs;\n    this.canvas = this.imageJs.getCanvas();\n    this._isLoaded = true;\n  }\n\n  public static getResource(name: string): Resource | undefined {\n    return registry.getEntry({ name });\n  }\n\n  public static getLoadedResource(name: string): LoadedResource | undefined {\n    const resource = registry.getEntry({ name });\n    if (!resource || !resource.isLoaded()) {\n      return;\n    }\n    return resource;\n  }\n}\n","export class Registry<T> {\n  private dict: { [id: string]: T } = {};\n\n  constructor(public idFields: Array<keyof T>) {}\n\n  private getId(partialEntry: Partial<T>): string {\n    const key: Partial<T> = {};\n    this.idFields.forEach((idField) => {\n      key[idField] = partialEntry[idField];\n    });\n    return JSON.stringify(key);\n  }\n\n  public addEntry(entry: T): void {\n    this.dict[this.getId(entry)] = entry;\n  }\n\n  public getEntry(partialEntry: Partial<T>): T | undefined {\n    return this.dict[this.getId(partialEntry)];\n  }\n}\n","import { Window, Position } from '../interfaces';\nimport { CrossSection } from './CrossSection';\nimport { TileMap } from '../Map';\nimport _ from 'lodash';\nimport { Sprite } from './Renderer';\n\nexport class ViewCone {\n  public crossSections: CrossSection[] = [];\n  private maxDistanceFromCenter: number;\n  public sprites: Sprite[] = [];\n  public canvas: OffscreenCanvas;\n  public context: OffscreenCanvasRenderingContext2D;\n  public recentering = false;\n\n  constructor(\n    public center: Position,\n    public focal: number,\n    public rendererWindow: Window,\n    public startDistanceFromCenter: number,\n    public tileMap: TileMap,\n    public zoom: number,\n  ) {\n    this.maxDistanceFromCenter = startDistanceFromCenter - 1;\n\n    const { canvas, context } = this.newCanvasAndContext();\n    this.canvas = canvas;\n    this.context = context;\n  }\n\n  private newCanvasAndContext(): { canvas: OffscreenCanvas; context: OffscreenCanvasRenderingContext2D } {\n    const canvas = new OffscreenCanvas(this.width * this.zoom, this.height * this.zoom);\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error(`Context cannot be null`);\n    }\n    context.imageSmoothingEnabled = false;\n    return { canvas, context };\n  }\n\n  public paintCanvas(): void {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    // TODO do not sort the cross-sections each time\n    const orderedCrossSections = _.orderBy(this.crossSections, ['buildingDistanceFromCenter'], ['desc']);\n    orderedCrossSections.forEach((crossSection) => {\n      const s = crossSection.sprite;\n      if (s) {\n        this.context.drawImage(s.image, s.sx, s.sy, s.sw, s.sh, 0, 0, this.canvas.width, this.canvas.height);\n      }\n    });\n  }\n\n  public get window(): Window {\n    return {\n      a1: this.rendererWindow.a1 / this.zoom,\n      a2: this.rendererWindow.a2 / this.zoom,\n      b1: this.rendererWindow.b1 / this.zoom,\n      b2: this.rendererWindow.b2 / this.zoom,\n    };\n  }\n\n  public async discover(depth: number): Promise<void> {\n    const maxDistanceFromCenter = this.maxDistanceFromCenter;\n    let t = Date.now();\n    const workFor = 20;\n    for (let distance = maxDistanceFromCenter + 1; distance <= maxDistanceFromCenter + depth; distance++) {\n      if (Date.now() - t >= workFor) {\n        await new Promise((r) => setImmediate(r));\n        t = Date.now();\n      }\n      const crossSection = await new CrossSection(this.center, this.focal, this.window, distance, this.tileMap);\n      this.crossSections.push(crossSection);\n      this.maxDistanceFromCenter = distance - 1;\n    }\n  }\n\n  public get width(): number {\n    return this.window.a2 - this.window.a1;\n  }\n\n  public get height(): number {\n    return this.window.b2 - this.window.b1;\n  }\n\n  public move(newCenter: Position, newFocal: number): void {\n    let cs: CrossSection | undefined;\n    this.crossSections.forEach((crossSection) => {\n      crossSection.move(newCenter, newFocal);\n      if (crossSection.sprite && !cs) {\n        cs = crossSection;\n      }\n    });\n\n    if (!cs || !cs.sprite) {\n      return;\n    }\n    const p = 1 / 4;\n    if (\n      cs.sprite.sx < cs.margin.a * p ||\n      cs.sprite.sy < cs.margin.b * p ||\n      cs.sprite.sx + cs.sprite.sw > cs.buildingParams.extendedWidth - cs.margin.a * p ||\n      cs.sprite.sy + cs.sprite.sh > cs.buildingParams.extendedHeight - cs.margin.b * p\n    ) {\n      this.recenter();\n    }\n  }\n\n  public async recenter() {\n    if (this.recentering) {\n      return;\n    }\n    this.recentering = true;\n    let t = Date.now();\n    const workFor = 20;\n    for (const crossSection of this.crossSections) {\n      if (Date.now() - t >= workFor) {\n        await new Promise((r) => setImmediate(r));\n        t = Date.now();\n      }\n      crossSection.recenter();\n    }\n    this.recentering = false;\n  }\n\n  // public async recenter(newCenter: Position, newFocal: number): Promise<void> {\n  //   for (let i = 0; i < this.crossSections.length; i++) {\n  //     await new Promise((r) => setImmediate(r));\n  //     const newCS = await this.crossSections[i].recenter(newCenter, newFocal);\n  //     this.crossSections[i] = newCS;\n  //   }\n\n  //   // TODO\n  //   // remove CS that are now too close\n  // }\n\n  // public updateTileAt(position: Position): void {\n  //   const crossSectionConstant = position.x + position.y + position.z / 3;\n  //   const crossSection = this.crossSections.find(\n  //     (cs) => Math.abs(cs.crossSectionConstant - crossSectionConstant) <= 0.001,\n  //   );\n  //   if (!crossSection) {\n  //     return;\n  //   }\n  //   crossSection.updatePosition(position);\n  // }\n\n  // public removeTileAt(position: Position): void {\n  //   const crossSectionConstant = position.x + position.y + position.z / 3;\n  //   const crossSection = this.crossSections.find((cs) => cs.crossSectionConstant === crossSectionConstant);\n  //   if (!crossSection) {\n  //     return;\n  //   }\n  //   crossSection.updatePosition(position);\n\n  //   this.updateTileAt({ ...position, z: position.z + 1 });\n  //   this.updateTileAt({ ...position, x: position.x + 1 });\n  //   this.updateTileAt({ ...position, y: position.y + 1 });\n  //   this.updateTileAt({ ...position, y: position.y - 1 });\n  //   this.updateTileAt({ ...position, x: position.x - 1 });\n  //   this.updateTileAt({ ...position, z: position.z - 1 });\n  // }\n}\n","import { Image as ImageJs } from 'image-js';\r\nimport { Registry } from './Registry';\r\nimport { Resource, LoadedResource } from './Resource';\r\n\r\nconst registry = new Registry<Tile>(['type', 'neighborhood']);\r\n\r\nconst MASK_RESOURCE_NAME = 'mask';\r\nenum MASK {\r\n  FTL = 64329,\r\n  LSL = 63735,\r\n  LSB = 10280,\r\n  LST = 62509,\r\n  FBL = 65277,\r\n  LSR = 57567,\r\n  FTR = 53199,\r\n  FBR = 0,\r\n  RSL = 59623,\r\n  RSB = 27296,\r\n  RST = 16824,\r\n  RSR = 61807,\r\n}\r\n\r\nexport interface TileNeighborhood {\r\n  above: boolean;\r\n  topLeft: boolean;\r\n  topRight: boolean;\r\n  bottomLeft: boolean;\r\n  bottomRight: boolean;\r\n  under: boolean;\r\n}\r\n\r\nexport class Tile {\r\n  public imageJs?: ImageJs;\r\n  public canvas?: HTMLCanvasElement;\r\n  private maskResource: LoadedResource;\r\n  private tileResource: LoadedResource;\r\n\r\n  constructor(public type: string, public neighborhood: TileNeighborhood) {\r\n    const tileResource = Resource.getLoadedResource(type);\r\n    if (!tileResource) {\r\n      throw new Error(`Resource '${type}' hasn't been loaded.`);\r\n    }\r\n    const maskResource = Resource.getLoadedResource(MASK_RESOURCE_NAME);\r\n    if (!maskResource) {\r\n      throw new Error(`Resource '${MASK_RESOURCE_NAME}' hasn't been loaded.`);\r\n    }\r\n    this.tileResource = tileResource;\r\n    this.maskResource = maskResource;\r\n\r\n    this.imageJs = this.makeImageJs();\r\n    this.canvas = this.imageJs?.getCanvas();\r\n\r\n    registry.addEntry(this);\r\n  }\r\n\r\n  public static getTile(type: string, neighborhood: TileNeighborhood): Tile | undefined {\r\n    return registry.getEntry({ type, neighborhood });\r\n  }\r\n\r\n  public static getOrMakeTile(type: string, neighborhood: TileNeighborhood): Tile {\r\n    const tile = registry.getEntry({ type, neighborhood });\r\n    if (tile) {\r\n      return tile;\r\n    }\r\n    return new Tile(type, neighborhood);\r\n  }\r\n\r\n  private makeImageJs(): ImageJs | undefined {\r\n    const { above, topLeft, topRight, bottomLeft, bottomRight, under } = this.neighborhood;\r\n    // const { above, topLeft, topRight, bottomLeft, bottomRight, under } = {\r\n    //   above: false,\r\n    //   topLeft: false,\r\n    //   topRight: false,\r\n    //   bottomLeft: false,\r\n    //   bottomRight: false,\r\n    //   under: false,\r\n    // };\r\n\r\n    if (above && bottomLeft && bottomRight) {\r\n      return;\r\n    }\r\n\r\n    const ressourceImage = this.tileResource.imageJs;\r\n    const maskImage = this.maskResource.imageJs;\r\n    // the TS declaration of ImageJs is incorrect: 3rd arg can (and must) be undefined\r\n    // eslint-disable-next-line\r\n    // @ts-ignore\r\n    const tileImage = new ImageJs(32, 24, undefined, {\r\n      bitDepth: 16,\r\n    });\r\n\r\n    for (let x = 0; x < 32; x++) {\r\n      for (let y = 0; y < 24; y++) {\r\n        tileImage.setPixelXY(x, y, [0, 0, 0, 0]);\r\n        const maskValue = maskImage.getPixelXY(x, y);\r\n        if (maskValue[0] === MASK.FTL) {\r\n          if (above === true) {\r\n            continue;\r\n          }\r\n          if (topLeft === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.FTR) {\r\n          if (above === true) {\r\n            continue;\r\n          }\r\n          if (topRight === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.FBL) {\r\n          if (above === true) {\r\n            continue;\r\n          }\r\n          if (bottomLeft === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.FBR) {\r\n          if (above === true) {\r\n            continue;\r\n          }\r\n          if (bottomRight === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.LSL) {\r\n          if (bottomLeft === true) {\r\n            if (above === true) {\r\n              continue;\r\n            }\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n            continue;\r\n          }\r\n          if (topLeft === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.LST) {\r\n          if (bottomLeft === true) {\r\n            if (above === true) {\r\n              continue;\r\n            }\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n            continue;\r\n          }\r\n          if (above === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.LSB) {\r\n          if (bottomLeft === true) {\r\n            if (above === true) {\r\n              continue;\r\n            }\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n            continue;\r\n          }\r\n          if (under === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.LSR) {\r\n          if (bottomLeft === true) {\r\n            if (above === true) {\r\n              continue;\r\n            }\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n            continue;\r\n          }\r\n          if (bottomRight === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.RSR) {\r\n          if (bottomRight === true) {\r\n            if (above === true) {\r\n              continue;\r\n            }\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n            continue;\r\n          }\r\n          if (topRight === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.RST) {\r\n          if (bottomRight === true) {\r\n            if (above === true) {\r\n              continue;\r\n            }\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n            continue;\r\n          }\r\n          if (above === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.RSB) {\r\n          if (bottomRight === true) {\r\n            if (above === true) {\r\n              continue;\r\n            }\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n            continue;\r\n          }\r\n          if (under === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\r\n          continue;\r\n        }\r\n        if (maskValue[0] === MASK.RSL) {\r\n          if (bottomRight === true) {\r\n            if (above === true) {\r\n              continue;\r\n            }\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\r\n            continue;\r\n          }\r\n          if (bottomLeft === false) {\r\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\r\n            continue;\r\n          }\r\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    return tileImage;\r\n  }\r\n}\r\n","import { Window, Position, CrossSectionPosition } from '../interfaces';\nimport { TileMap } from '../Map';\nimport { Tile, TileNeighborhood } from './Tile';\n\nexport interface SpriteCropParams {\n  sx: number;\n  sy: number;\n  sw: number;\n  sh: number;\n}\n\nexport interface Sprite {\n  image: OffscreenCanvas;\n  sx: number;\n  sy: number;\n  sw: number;\n  sh: number;\n}\n\nexport interface PositionedTile {\n  position: Position;\n  crossSectionPosition: CrossSectionPosition;\n  tile: Tile;\n}\n\nexport interface TilesDict {\n  [key: string]: PositionedTile;\n}\n\nexport interface CrossSectionParams {\n  center: Position;\n  scale: number;\n  window: Window;\n  width: number;\n  height: number;\n  extendedWindow: Window;\n  extendedWidth: number;\n  extendedHeight: number;\n  heightConstraint: number;\n  crossSectionConstant: number;\n}\n\nexport class CrossSection {\n  public buildingDistanceFromCenter: number;\n  public actualDistanceFromCenter: number;\n  public buildingViewConeCenter: Position;\n  public actualViewConeCenter: Position;\n  public actualFocal: number;\n  public buildingFocal: number;\n  private actualParams: CrossSectionParams;\n  public buildingParams: CrossSectionParams;\n  private tilesDict: TilesDict;\n  private canvas?: OffscreenCanvas;\n  private context?: OffscreenCanvasRenderingContext2D;\n  private spriteCropParams: SpriteCropParams;\n  public isRecentering = false;\n\n  constructor(\n    viewConeCenter: Position,\n    public focal: number,\n    public viewConeWindow: Window,\n    distanceFromCenter: number,\n    public tileMap: TileMap,\n    public margin: CrossSectionPosition = { a: 160, b: 80 },\n  ) {\n    this.buildingViewConeCenter = {\n      x: Math.round(viewConeCenter.x),\n      y: Math.round(viewConeCenter.y),\n      z: Math.round(viewConeCenter.z),\n    };\n    this.actualViewConeCenter = viewConeCenter;\n\n    const distanceDiff = CrossSection.getDistanceBetween(this.buildingViewConeCenter, viewConeCenter);\n    this.buildingDistanceFromCenter = Math.round(distanceFromCenter + distanceDiff);\n    this.actualDistanceFromCenter = Math.round(distanceFromCenter);\n\n    this.actualFocal = focal;\n    this.buildingFocal = focal;\n\n    this.actualParams = CrossSection.getCrossSectionParams(\n      this.actualViewConeCenter,\n      focal,\n      viewConeWindow,\n      this.actualDistanceFromCenter,\n      margin,\n    );\n\n    this.buildingParams = CrossSection.getCrossSectionParams(\n      this.buildingViewConeCenter,\n      focal,\n      viewConeWindow,\n      this.buildingDistanceFromCenter,\n      margin,\n    );\n\n    this.spriteCropParams = this.getSpriteCropParams();\n\n    this.tilesDict = this.makeTilesDict();\n    this.paintCanvas();\n  }\n\n  private getSpriteCropParams(): SpriteCropParams {\n    const { a, b } = this.getCrossSectionPosition(this.actualParams.center);\n\n    return {\n      sx: this.margin.a + a + Math.round(this.buildingParams.extendedWidth / 2) - this.actualParams.extendedWidth / 2,\n      sy: this.margin.b - b + Math.round(this.buildingParams.extendedHeight / 2) - this.actualParams.extendedHeight / 2,\n      sw: this.actualParams.width,\n      sh: this.actualParams.height,\n    };\n  }\n\n  public static getCrossSectionParams(\n    viewConeCenter: Position,\n    focal: number,\n    viewConeWindow: Window,\n    distanceFromCenter: number,\n    margin: CrossSectionPosition,\n  ): CrossSectionParams {\n    const center = {\n      x: viewConeCenter.x - distanceFromCenter / 8,\n      y: viewConeCenter.y - distanceFromCenter / 8,\n      z: viewConeCenter.z - distanceFromCenter / 4,\n    };\n\n    const scale = 1 + distanceFromCenter / focal;\n\n    const window = {\n      a1: viewConeWindow.a1 * scale,\n      a2: viewConeWindow.a2 * scale,\n      b1: viewConeWindow.b1 * scale,\n      b2: viewConeWindow.b2 * scale,\n    };\n\n    const width = window.a2 - window.a1;\n    const height = window.b2 - window.b1;\n\n    const extendedWindow = {\n      a1: window.a1 - margin.a,\n      a2: window.a2 + margin.a,\n      b1: window.b1 - margin.b,\n      b2: window.b2 + margin.b,\n    };\n\n    const extendedWidth = extendedWindow.a2 - extendedWindow.a1;\n    const extendedHeight = extendedWindow.b2 - extendedWindow.b1;\n\n    const heightConstraint = CrossSection.getHeightConstraint(viewConeCenter.z - distanceFromCenter);\n\n    const crossSectionConstant = CrossSection.getCrossSectionConstant(center);\n\n    return {\n      center,\n      scale,\n      window,\n      width,\n      height,\n      extendedWindow,\n      extendedWidth,\n      extendedHeight,\n      heightConstraint,\n      crossSectionConstant,\n    };\n  }\n\n  public static getCrossSectionConstant(position: Position): number {\n    return position.x + position.y + position.z / 3;\n  }\n\n  public static getDistanceBetween(p1: Position, p2: Position): number {\n    const k1 = CrossSection.getCrossSectionConstant(p1);\n    const k2 = CrossSection.getCrossSectionConstant(p2);\n    return 3 * (k1 - k2);\n  }\n\n  public get sprite(): Sprite | undefined {\n    if (!this.canvas) {\n      return;\n    }\n    const { sx, sy, sw, sh } = this.spriteCropParams;\n    return {\n      image: this.canvas,\n      sx,\n      sy,\n      sw,\n      sh,\n    };\n  }\n\n  private newCanvasAndContext(): { canvas: OffscreenCanvas; context: OffscreenCanvasRenderingContext2D } {\n    const canvas = new OffscreenCanvas(this.buildingParams.extendedWidth, this.buildingParams.extendedHeight);\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error(`Context cannot be null`);\n    }\n    context.imageSmoothingEnabled = false;\n    return { canvas, context };\n  }\n\n  public paintCanvas(): void {\n    const tiles = this.tiles;\n    if (tiles.length === 0 || tiles.every(({ tile }) => !tile.canvas)) {\n      if (this.context) {\n        delete this.context;\n        delete this.canvas;\n      }\n      return;\n    }\n\n    if (!this.context) {\n      const { canvas, context } = this.newCanvasAndContext();\n      this.canvas = canvas;\n      this.context = context;\n    }\n\n    this.context.clearRect(0, 0, this.buildingParams.extendedWidth, this.buildingParams.extendedHeight);\n    //this.context.globalAlpha = 0.3;\n    tiles.forEach(({ crossSectionPosition: { a, b }, tile }) => {\n      if (!tile.canvas || !this.context) {\n        return;\n      }\n      this.context.drawImage(\n        tile.canvas,\n        Math.round(this.buildingParams.extendedWidth / 2) + (a - 16),\n        Math.round(this.buildingParams.extendedHeight / 2) + (-b - 8),\n        tile.canvas.width,\n        tile.canvas.height,\n      );\n    });\n  }\n\n  public static getHeightConstraint(z: number): number {\n    return (3 + (z % 3)) % 3;\n  }\n\n  public getA({ x, y }: { x: number; y: number }): number {\n    return 16 * (y - this.buildingParams.center.y - (x - this.buildingParams.center.x));\n  }\n  public getB({ z }: { z: number }): number {\n    return (32 / 3) * (z - this.buildingParams.center.z);\n  }\n\n  public getCrossSectionPosition(point: Position): CrossSectionPosition {\n    return {\n      a: this.getA(point),\n      b: this.getB(point),\n    };\n  }\n\n  public getX({ a, b }: CrossSectionPosition): number {\n    return this.buildingParams.center.x - a / 32 - b / 64;\n  }\n  public getY({ a, b }: CrossSectionPosition): number {\n    return this.buildingParams.center.y + a / 32 - b / 64;\n  }\n  public getZ({ b }: { b: number }): number {\n    return this.buildingParams.center.z + (3 * b) / 32;\n  }\n\n  public getPosition(cpp: CrossSectionPosition): Position {\n    return {\n      x: this.getX(cpp),\n      y: this.getY(cpp),\n      z: this.getZ(cpp),\n    };\n  }\n\n  public forEachTilePosition(cb: (position: Position) => void, zMinBorder?: number, zMaxBorder?: number): void {\n    const { a1, a2, b1, b2 } = this.buildingParams.extendedWindow;\n\n    const k = this.buildingParams.heightConstraint;\n\n    // first integer z in the area\n    let zMin = Math.ceil(this.getZ({ b: b1 }));\n    if (zMinBorder && zMinBorder > zMin) {\n      zMin = zMinBorder;\n    }\n    // first multiple of ki after zMin\n    const k1 = CrossSection.getHeightConstraint(zMin);\n    if (k1 !== k) {\n      zMin = zMin + CrossSection.getHeightConstraint(k - k1);\n    }\n\n    // last integer z in the area\n    let zMax = Math.floor(this.getZ({ b: b2 }));\n    if (zMaxBorder && zMaxBorder < zMax) {\n      zMax = zMaxBorder;\n    }\n    // last multiple of ki before zMax\n    const k2 = CrossSection.getHeightConstraint(zMax);\n    if (k2 !== k) {\n      zMax = zMax - CrossSection.getHeightConstraint(-k + k2);\n    }\n\n    for (let z = zMin; z <= zMax; z += 3) {\n      const b = this.getB({ z });\n      // first integer y in the line z of the area\n      const yMin = Math.ceil(this.getY({ a: a1, b }));\n      // last integer y in the line z of the area\n      const yMax = Math.floor(this.getY({ a: a2, b }));\n      for (let y = yMin; y <= yMax; y++) {\n        const x = Math.round(this.buildingParams.crossSectionConstant - y - z / 3);\n        cb({ x, y, z });\n      }\n    }\n  }\n\n  public get tiles(): PositionedTile[] {\n    return Object.values(this.tilesDict);\n  }\n\n  public static getTileId(position: Position): string {\n    return JSON.stringify(position);\n  }\n\n  public makeTilesDict(): TilesDict {\n    const tilesDict: TilesDict = {};\n    const tileMap = this.tileMap;\n\n    // check if it may be useless to do anything\n    const { a1, a2, b1, b2 } = this.buildingParams.extendedWindow;\n    if (tileMap.crossSectionIsEmpty(this.getPosition({ a: a1, b: b1 }), this.getPosition({ a: a2, b: b2 }))) {\n      return tilesDict;\n    }\n\n    this.forEachTilePosition(\n      (position) => {\n        const id = CrossSection.getTileId(position);\n        const value = tileMap.getTileAt(position);\n        if (value) {\n          const neighborhood: TileNeighborhood = {\n            above: tileMap.getTileAt({ ...position, z: position.z + 1 }) === 1,\n            bottomLeft: tileMap.getTileAt({ ...position, x: position.x + 1 }) === 1,\n            bottomRight: tileMap.getTileAt({ ...position, y: position.y + 1 }) === 1,\n            topLeft: tileMap.getTileAt({ ...position, y: position.y - 1 }) === 1,\n            topRight: tileMap.getTileAt({ ...position, x: position.x - 1 }) === 1,\n            under: tileMap.getTileAt({ ...position, z: position.z - 1 }) === 1,\n          };\n          const tile = Tile.getOrMakeTile('tile2', neighborhood);\n          tilesDict[id] = {\n            position,\n            crossSectionPosition: this.getCrossSectionPosition(position),\n            tile,\n          };\n        }\n      },\n      tileMap.borders.zMin,\n      tileMap.borders.zMax,\n    );\n\n    return tilesDict;\n  }\n\n  public move(newViewConeCenter: Position, newFocal: number): void {\n    const distanceDiff = CrossSection.getDistanceBetween(newViewConeCenter, this.actualViewConeCenter);\n    this.actualDistanceFromCenter += distanceDiff;\n    this.actualViewConeCenter = newViewConeCenter;\n    this.actualFocal = newFocal;\n    this.actualParams = CrossSection.getCrossSectionParams(\n      newViewConeCenter,\n      newFocal,\n      this.viewConeWindow,\n      this.actualDistanceFromCenter,\n      this.margin,\n    );\n\n    this.spriteCropParams = this.getSpriteCropParams();\n\n    const { sx, sy, sw, sh } = this.spriteCropParams;\n\n    const p = 3 / 4;\n    if (\n      sx < this.margin.a * p ||\n      sy < this.margin.b * p ||\n      sx + sw > this.buildingParams.extendedWidth - this.margin.a * p ||\n      sy + sh > this.buildingParams.extendedHeight - this.margin.b * p\n    ) {\n      // this.recenter();\n    }\n  }\n\n  public recenter() {\n    if (this.isRecentering) {\n      return;\n    }\n    this.isRecentering = true;\n    //await new Promise((r) => setImmediate(r));\n    const newCs = new CrossSection(\n      this.actualViewConeCenter,\n      this.actualFocal,\n      this.viewConeWindow,\n      this.actualDistanceFromCenter,\n      this.tileMap,\n      this.margin,\n    );\n    this.buildingViewConeCenter = newCs.buildingViewConeCenter;\n    this.buildingDistanceFromCenter = newCs.buildingDistanceFromCenter;\n    this.buildingParams = newCs.buildingParams;\n    this.buildingFocal = newCs.buildingFocal;\n    this.tilesDict = newCs.tilesDict;\n    this.canvas = newCs.canvas;\n    this.context = newCs.context;\n    this.spriteCropParams = this.getSpriteCropParams();\n    this.isRecentering = false;\n  }\n\n  // public recenter(newViewConeCenter: Position, newFocal: number): CrossSection {\n  //   const k2 = newViewConeCenter.x + newViewConeCenter.y + newViewConeCenter.z / 3;\n  //   const k1 = this.viewConeCenter.x + this.viewConeCenter.y + this.viewConeCenter.z / 3;\n  //   const distanceDiff = 3 * (k2 - k1);\n  //   const newDistanceFromCenter = this.distanceFromCenter + distanceDiff;\n\n  //   // TODO\n  //   // instead of doing 1 new, do up to 4 smaller without margin and merge them into the current one\n\n  //   const newCs = new CrossSection(\n  //     newViewConeCenter,\n  //     newFocal,\n  //     this.viewConeWindow,\n  //     newDistanceFromCenter,\n  //     this.tileMap,\n  //     this.margin,\n  //     this.tilesDict,\n  //   );\n  //   return newCs;\n  // }\n\n  // public updatePosition(position: Position): void {\n  //   const tileMap = this.tileMap;\n  //   const value = tileMap.getTileAt(position);\n  //   const id = CrossSection.getTileId(position);\n  //   if (!value) {\n  //     delete this.tilesDict[id];\n  //     return;\n  //   }\n  //   const neighborhood: TileNeighborhood = {\n  //     above: tileMap.getTileAt({ ...position, z: position.z + 1 }) === 1,\n  //     bottomLeft: tileMap.getTileAt({ ...position, x: position.x + 1 }) === 1,\n  //     bottomRight: tileMap.getTileAt({ ...position, y: position.y + 1 }) === 1,\n  //     topLeft: tileMap.getTileAt({ ...position, y: position.y - 1 }) === 1,\n  //     topRight: tileMap.getTileAt({ ...position, x: position.x - 1 }) === 1,\n  //     under: tileMap.getTileAt({ ...position, z: position.z - 1 }) === 1,\n  //   };\n  //   const tile = Tile.getOrMakeTile('tile2', neighborhood);\n  //   this.tilesDict[id] = {\n  //     position,\n  //     crossSectionPosition: this.getCrossSectionPosition(position),\n  //     tile,\n  //   };\n  // }\n}\n"],"sourceRoot":""}