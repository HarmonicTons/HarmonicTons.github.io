{"version":3,"sources":["Game/math.ts","Game/Map.ts","Game/renderer/Renderer.ts","Game/index.ts","Stage.tsx","App.tsx","serviceWorker.ts","index.tsx","Game/renderer/Resource.ts","Game/renderer/Registry.ts","Game/renderer/ViewCone.ts","Game/renderer/Tile.ts","Game/renderer/CrossSection.ts"],"names":["toPrecision","n","p","Math","round","TileMap","dict","chunksDicts","borders","chunkSizes","this","map","z","x","y","getKeyFromPosition","X13","Y13","firstPosition","getPositionFromKey","Object","keys","xMin","xMax","yMin","yMax","zMin","zMax","setChunksAndBorders","position","JSON","stringify","key","parse","chunkSize","a","b","c","chunkPosition","floor","getChunkKeyFromChunkPosition","getChunkPosition","forEach","chunksDict","i","getChunkKeyFromPosition","p1","p2","cp1","cp2","reducedP1","min","max","reducedP2","length","_crossSectionIsEmpty","focal","Renderer","canvas","tileMap","context","viewCone","framesDuration","Array","fill","lastTime","frameIndex","getContext","Error","imageSmoothingEnabled","center","w","width","h","height","nativeZoom","postRenderZoom","window","a1","a2","b1","b2","ViewCone","Date","now","renderLoop","init","console","time","discover","timeEnd","move","Promise","r","setTimeout","newViewCone","rendererWindow","startDistanceFromCenter","zoom","t","push","shift","log","fps","toFixed","paintCanvas","requestAnimationFrame","clearRect","drawImage","reduce","sum","d","Game","tile1Resource","Resource","load","tile2Resource","maskResource","Stage","canvasEl","useRef","useEffect","current","start","ref","style","border","margin","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","registry","Registry","name","url","imageJs","_isLoaded","process","addEntry","ImageJs","getCanvas","getEntry","resource","isLoaded","idFields","partialEntry","idField","entry","getId","crossSections","maxDistanceFromCenter","sprites","newCanvasAndContext","OffscreenCanvas","_","orderBy","crossSection","s","sprite","image","sx","sy","sw","sh","depth","distance","setImmediate","CrossSection","newCenter","newFocal","MASK","Tile","type","neighborhood","tileResource","getLoadedResource","makeImageJs","above","topLeft","topRight","bottomLeft","bottomRight","under","ressourceImage","maskImage","tileImage","undefined","bitDepth","setPixelXY","maskValue","getPixelXY","FTL","FTR","FBL","FBR","LSL","LST","LSB","LSR","RSR","RST","RSB","RSL","tile","viewConeCenter","viewConeWindow","distanceFromCenter","scale","extendedWindow","heightConstraint","crossSectionConstant","tilesDict","da","db","dw","dh","getHeightConstraint","makeTilesDict","extendedWidth","extendedHeight","tiles","every","crossSectionPosition","point","getA","getB","cpp","getX","getY","getZ","cb","zMinBorder","zMaxBorder","k","ceil","k1","k2","crossSectionIsEmpty","getPosition","forEachTilePosition","getTileAt","getOrMakeTile","getTileId","getCrossSectionPosition","newViewConeCenter","distanceDiff","newScale","newWindow","newExtendedWindow","newExtendedWidth","newExtendedHeight","projetedNewCenter","dPosition","values"],"mappings":"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","file":"static/js/main.6f30049e.chunk.js","sourcesContent":["export const toPrecision = (n: number, p = 3): number => {\n  return Math.round(n * 10 ** p) / 10 ** p;\n};\n","import { Position } from './interfaces';\nimport { toPrecision as p } from './math';\n\ninterface ChunkPosition {\n  a: number;\n  b: number;\n  c: number;\n}\n\nexport interface Borders {\n  xMin: number;\n  xMax: number;\n  yMin: number;\n  yMax: number;\n  zMin: number;\n  zMax: number;\n}\n\nexport class TileMap {\n  private dict: {\n    [key: string]: number;\n  } = {};\n  private chunksDicts: {\n    [key: string]: boolean;\n  }[];\n\n  public borders: Borders;\n  private chunkSizes = [40, 20, 10, 5];\n  constructor() {\n    // TODO load from JSON\n\n    this.chunksDicts = this.chunkSizes.map(() => ({}));\n\n    const X01 = -2;\n    const Y01 = -2;\n    const X11 = 2;\n    const Y11 = 2;\n    const Z0 = -100;\n    const Z1 = 0;\n\n    for (let z = Z0; z <= Z1; z++) {\n      for (let x = X01; x <= X11; x++) {\n        for (let y = Y01; y <= Y11; y++) {\n          this.dict[this.getKeyFromPosition({ x, y, z })] = 1;\n        }\n      }\n    }\n\n    const X02 = -100;\n    const Y02 = -100;\n    const X12 = 100;\n    const Y12 = 100;\n    const Z2 = -103;\n    const Z22 = -100;\n\n    for (let z = Z2; z <= Z22; z++) {\n      for (let x = X02; x <= X12; x++) {\n        for (let y = Y02; y <= Y12; y++) {\n          if ((x + y) % 2 === -1) {\n            //continue;\n          }\n          this.dict[this.getKeyFromPosition({ x, y, z })] = 1;\n        }\n      }\n    }\n\n    const i = 50;\n    const X03 = -4 + i;\n    const Y03 = 0 + i;\n    const X13 = 0 + i;\n    const Y13 = 4 + i;\n\n    for (let x = X03; x <= X13; x++) {\n      for (let y = Y03; y <= Y13; y++) {\n        this.dict[this.getKeyFromPosition({ x, y, z: 2 * i })] = 1;\n      }\n    }\n    this.dict[this.getKeyFromPosition({ x: X13 - 1, y: Y13 + 1, z: 2 * i })] = 1;\n    this.dict[this.getKeyFromPosition({ x: X13 - 3, y: Y13 + 1, z: 2 * i })] = 1;\n    this.dict[this.getKeyFromPosition({ x: X13 - 1, y: Y13 + 2, z: 2 * i })] = 1;\n    this.dict[this.getKeyFromPosition({ x: X13 - 3, y: Y13 + 2, z: 2 * i })] = 1;\n    this.dict[this.getKeyFromPosition({ x: X13 - 2, y: Y13 + 2, z: 2 * i })] = 1;\n\n    const firstPosition = this.getPositionFromKey(Object.keys(this.dict)[0]);\n    this.borders = {\n      xMin: firstPosition.x,\n      xMax: firstPosition.x,\n      yMin: firstPosition.y,\n      yMax: firstPosition.y,\n      zMin: firstPosition.z,\n      zMax: firstPosition.z,\n    };\n\n    this.setChunksAndBorders();\n  }\n\n  private getKeyFromPosition(position: Position): string {\n    return JSON.stringify(position);\n  }\n\n  private getPositionFromKey(key: string): Position {\n    return JSON.parse(key);\n  }\n\n  private getChunkPosition(chunkSize: number, position: Position): ChunkPosition {\n    return {\n      a: p((position.y - position.x) / chunkSize),\n      b: p((position.y + position.x + position.z / 3) / chunkSize),\n      c: p(position.z / chunkSize),\n    };\n  }\n\n  private getChunkKeyFromChunkPosition(chunkPosition: ChunkPosition): string {\n    return JSON.stringify({\n      a: Math.floor(chunkPosition.a),\n      b: Math.floor(chunkPosition.b),\n      c: Math.floor(chunkPosition.c),\n    });\n  }\n\n  private getChunkKeyFromPosition(chunkSize: number, position: Position): string {\n    return this.getChunkKeyFromChunkPosition(this.getChunkPosition(chunkSize, position));\n  }\n\n  public getTileAt(position: Position): number {\n    return this.dict[this.getKeyFromPosition(position)];\n  }\n\n  public setChunksAndBorders(): void {\n    Object.keys(this.dict).forEach((key) => {\n      const position = this.getPositionFromKey(key);\n      if (position.x < this.borders.xMin) {\n        this.borders.xMin = position.x;\n      }\n      if (position.x > this.borders.xMax) {\n        this.borders.xMax = position.x;\n      }\n      if (position.y < this.borders.yMin) {\n        this.borders.yMin = position.y;\n      }\n      if (position.y > this.borders.yMax) {\n        this.borders.yMax = position.y;\n      }\n      if (position.z < this.borders.zMin) {\n        this.borders.zMin = position.z;\n      }\n      if (position.z > this.borders.zMax) {\n        this.borders.zMax = position.z;\n      }\n      this.chunksDicts.forEach((chunksDict, i) => {\n        chunksDict[this.getChunkKeyFromPosition(this.chunkSizes[i], position)] = true;\n      });\n    });\n  }\n\n  public _crossSectionIsEmpty(chunksDict: any, chunkSize: number, p1: Position, p2: Position): boolean {\n    const cp1 = this.getChunkPosition(chunkSize, p1);\n    const cp2 = this.getChunkPosition(chunkSize, p2);\n    for (let a = Math.floor(cp1.a); a <= cp2.a; a++) {\n      for (let c = Math.floor(cp1.c); c <= cp2.c; c++) {\n        if (chunksDict[this.getChunkKeyFromChunkPosition({ a, b: cp1.b, c })]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  public crossSectionIsEmpty(p1: Position, p2: Position): boolean {\n    const reducedP1 = {\n      ...p1,\n      z: Math.min(this.borders.zMax, Math.max(this.borders.zMin, p1.z)),\n    };\n    const reducedP2 = {\n      ...p2,\n      z: Math.min(this.borders.zMax, Math.max(this.borders.zMin, p2.z)),\n    };\n    for (let i = 0; i < this.chunksDicts.length; i++) {\n      if (this._crossSectionIsEmpty(this.chunksDicts[i], this.chunkSizes[i], reducedP1, reducedP2) === true) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","import { TileMap } from '../Map';\nimport { Window, Position } from '../interfaces';\nimport { ViewCone } from './ViewCone';\n\nlet x = -2;\nlet y = -2;\nlet z = 0;\n\nlet focal = 1000;\n\nlet i = 0.01;\n\nexport interface Sprite {\n  image: HTMLCanvasElement | HTMLImageElement | OffscreenCanvas;\n  x: number;\n  y: number;\n  scale: number;\n}\n\nexport class Renderer {\n  private context: CanvasRenderingContext2D;\n  private viewCone: ViewCone;\n\n  private framesDuration: number[] = [...Array(30)].fill(0);\n  private lastTime = 0;\n  private frameIndex = 0;\n\n  constructor(public canvas: HTMLCanvasElement, public tileMap: TileMap) {\n    const context = this.canvas.getContext('2d');\n    if (!context) {\n      throw new Error(`Context cannot be null`);\n    }\n    context.imageSmoothingEnabled = false;\n    this.context = context;\n\n    const center: Position = { x, y, z };\n    const w = this.canvas.width;\n    const h = this.canvas.height;\n    const zoom = 4;\n    const zoomQuality = 1;\n    const nativeZoom = zoom ** zoomQuality;\n    const postRenderZoom = zoom ** (1 - zoomQuality);\n    const window: Window = {\n      a1: -w / 2 / postRenderZoom,\n      a2: w / 2 / postRenderZoom,\n      b1: -h / 2 / postRenderZoom,\n      b2: h / 2 / postRenderZoom,\n    };\n\n    this.viewCone = new ViewCone(center, focal, window, -500, tileMap, nativeZoom);\n\n    this.lastTime = Date.now();\n    this.renderLoop();\n\n    this.init();\n  }\n\n  public async init() {\n    console.time('discover');\n    await this.viewCone.discover(1500);\n    console.timeEnd('discover');\n    return;\n    await new Promise((r) => setTimeout(r, 2000));\n\n    x += -5;\n    y += 3;\n    z += -6;\n    focal *= 5;\n    this.viewCone.move({ x, y, z }, focal);\n\n    await new Promise((r) => setTimeout(r, 500));\n\n    const center: Position = { x, y, z };\n    const newViewCone = new ViewCone(\n      center,\n      focal,\n      this.viewCone.rendererWindow,\n      this.viewCone.startDistanceFromCenter,\n      this.viewCone.tileMap,\n      this.viewCone.zoom,\n    );\n    console.time('discover2');\n    await newViewCone.discover(1500);\n    console.timeEnd('discover2');\n    this.viewCone = newViewCone;\n  }\n\n  private get fps() {\n    return (this.framesDuration.length / this.framesDuration.reduce((sum, d) => sum + d, 0)) * 1000;\n  }\n\n  public renderLoop() {\n    const t = Date.now() - this.lastTime;\n    this.lastTime = Date.now();\n    this.framesDuration.push(t);\n    this.framesDuration.shift();\n\n    if (this.frameIndex++ % 30 === 0) {\n      console.log(this.fps.toFixed(1));\n    }\n\n    this.paintCanvas();\n    i += 0;\n    x += i;\n    y += 2 * i;\n    z -= 0;\n    focal += i * 1000;\n    if (x > 2) {\n      i = -0.01;\n    }\n    if (x < -2) {\n      i = +0.01;\n    }\n    this.viewCone.move({ x, y, z }, focal);\n    requestAnimationFrame(() => this.renderLoop());\n  }\n\n  public paintCanvas() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.context.drawImage(this.viewCone.canvas, 0, 0, this.canvas.width, this.canvas.height);\n  }\n}\n","import { TileMap } from './Map';\nimport { Resource } from './renderer/Resource';\nimport { Renderer } from './renderer/Renderer';\n\nexport class Game {\n  constructor(private readonly canvas: any) {}\n\n  async start(): Promise<void> {\n    const tile1Resource = new Resource('tile1');\n    await tile1Resource.load();\n    const tile2Resource = new Resource('tile2');\n    await tile2Resource.load();\n    const maskResource = new Resource('mask');\n    await maskResource.load();\n\n    const tileMap = new TileMap();\n    const renderer = new Renderer(this.canvas, tileMap);\n  }\n}\n","import React, { useRef, useEffect } from 'react';\nimport { Game } from './Game';\n\nconst Stage = (): JSX.Element => {\n  const canvasEl = useRef(null);\n  useEffect(() => {\n    if (!canvasEl || !canvasEl.current) {\n      return;\n    }\n    const game = new Game(canvasEl.current);\n    game.start();\n  }, [canvasEl]);\n\n  return (\n    <>\n      <canvas\n        width={1600}\n        height={800}\n        ref={canvasEl}\n        style={{\n          border: '1px solid black',\n          margin: '20px',\n        }}\n      />\n    </>\n  );\n};\n\nexport default Stage;\n","import React from 'react';\nimport Stage from './Stage';\n\nconst App = (): JSX.Element => {\n  return (\n    <div>\n      <p>IME</p>\n      <Stage />\n    </div>\n  );\n};\n\nexport default App;\n","/* eslint-disable */\n\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { Image as ImageJs } from 'image-js';\nimport { Registry } from './Registry';\n\nconst registry = new Registry<Resource>(['name']);\n\nexport interface LoadedResource extends Resource {\n  imageJs: ImageJs;\n}\n\nexport class Resource {\n  private url: string;\n  public imageJs?: ImageJs;\n  public canvas?: HTMLCanvasElement;\n  private _isLoaded = false;\n  constructor(public name: string) {\n    this.url = `${process.env.PUBLIC_URL}/${name}.png`;\n\n    registry.addEntry(this);\n  }\n\n  public isLoaded(): this is LoadedResource {\n    return this._isLoaded;\n  }\n\n  public async load(): Promise<void> {\n    const imageJs: ImageJs = await ImageJs.load(this.url);\n    this.imageJs = imageJs;\n    this.canvas = this.imageJs.getCanvas();\n    this._isLoaded = true;\n  }\n\n  public static getResource(name: string): Resource | undefined {\n    return registry.getEntry({ name });\n  }\n\n  public static getLoadedResource(name: string): LoadedResource | undefined {\n    const resource = registry.getEntry({ name });\n    if (!resource || !resource.isLoaded()) {\n      return;\n    }\n    return resource;\n  }\n}\n","export class Registry<T> {\n  private dict: { [id: string]: T } = {};\n\n  constructor(public idFields: Array<keyof T>) {}\n\n  private getId(partialEntry: Partial<T>): string {\n    const key: Partial<T> = {};\n    this.idFields.forEach((idField) => {\n      key[idField] = partialEntry[idField];\n    });\n    return JSON.stringify(key);\n  }\n\n  public addEntry(entry: T): void {\n    this.dict[this.getId(entry)] = entry;\n  }\n\n  public getEntry(partialEntry: Partial<T>): T | undefined {\n    return this.dict[this.getId(partialEntry)];\n  }\n}\n","import { Window, Position } from '../interfaces';\nimport { CrossSection } from './CrossSection';\nimport { TileMap } from '../Map';\nimport _ from 'lodash';\nimport { Sprite } from './Renderer';\n\nexport class ViewCone {\n  public crossSections: CrossSection[] = [];\n  private maxDistanceFromCenter: number;\n  public sprites: Sprite[] = [];\n  public canvas: OffscreenCanvas;\n  public context: OffscreenCanvasRenderingContext2D;\n\n  constructor(\n    public center: Position,\n    public focal: number,\n    public rendererWindow: Window,\n    public startDistanceFromCenter: number,\n    public tileMap: TileMap,\n    public zoom: number,\n  ) {\n    this.maxDistanceFromCenter = startDistanceFromCenter - 1;\n\n    const { canvas, context } = this.newCanvasAndContext();\n    this.canvas = canvas;\n    this.context = context;\n  }\n\n  private newCanvasAndContext(): { canvas: OffscreenCanvas; context: OffscreenCanvasRenderingContext2D } {\n    const canvas = new OffscreenCanvas(this.width * this.zoom, this.height * this.zoom);\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error(`Context cannot be null`);\n    }\n    context.imageSmoothingEnabled = false;\n    return { canvas, context };\n  }\n\n  public paintCanvas(): void {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    const orderedCrossSections = _.orderBy(this.crossSections, ['distanceFromCenter'], ['desc']);\n    orderedCrossSections.forEach((crossSection) => {\n      const s = crossSection.sprite;\n      if (s) {\n        this.context.drawImage(s.image, s.sx, s.sy, s.sw, s.sh, 0, 0, this.canvas.width, this.canvas.height);\n      }\n    });\n  }\n\n  public get window(): Window {\n    return {\n      a1: this.rendererWindow.a1 / this.zoom,\n      a2: this.rendererWindow.a2 / this.zoom,\n      b1: this.rendererWindow.b1 / this.zoom,\n      b2: this.rendererWindow.b2 / this.zoom,\n    };\n  }\n\n  public async discover(depth: number): Promise<void> {\n    const maxDistanceFromCenter = this.maxDistanceFromCenter;\n    for (let distance = maxDistanceFromCenter + 1; distance <= maxDistanceFromCenter + depth; distance++) {\n      await new Promise((r) => setImmediate(r));\n      const crossSection = await new CrossSection(this.center, this.focal, this.window, distance, this.tileMap);\n      await crossSection.paintCanvas();\n      this.crossSections.push(crossSection);\n      this.maxDistanceFromCenter = distance - 1;\n    }\n    await this.paintCanvas();\n  }\n\n  public get width(): number {\n    return this.window.a2 - this.window.a1;\n  }\n\n  public get height(): number {\n    return this.window.b2 - this.window.b1;\n  }\n\n  public move(newCenter: Position, newFocal: number): void {\n    this.crossSections.forEach((crossSection) => {\n      crossSection.move(newCenter, newFocal);\n    });\n    this.paintCanvas();\n  }\n}\n","import { Image as ImageJs } from 'image-js';\nimport { Registry } from './Registry';\nimport { Resource, LoadedResource } from './Resource';\n\nconst registry = new Registry<Tile>(['type', 'neighborhood']);\n\nconst MASK_RESOURCE_NAME = 'mask';\nenum MASK {\n  FTL = 64329,\n  LSL = 63735,\n  LSB = 10280,\n  LST = 62509,\n  FBL = 65277,\n  LSR = 57567,\n  FTR = 53199,\n  FBR = 0,\n  RSL = 59623,\n  RSB = 27296,\n  RST = 16824,\n  RSR = 61807,\n}\n\nexport interface TileNeighborhood {\n  above: boolean;\n  topLeft: boolean;\n  topRight: boolean;\n  bottomLeft: boolean;\n  bottomRight: boolean;\n  under: boolean;\n}\n\nexport class Tile {\n  public imageJs?: ImageJs;\n  public canvas?: HTMLCanvasElement;\n  private maskResource: LoadedResource;\n  private tileResource: LoadedResource;\n\n  constructor(public type: string, public neighborhood: TileNeighborhood) {\n    const tileResource = Resource.getLoadedResource(type);\n    if (!tileResource) {\n      throw new Error(`Resource '${type}' hasn't been loaded.`);\n    }\n    const maskResource = Resource.getLoadedResource(MASK_RESOURCE_NAME);\n    if (!maskResource) {\n      throw new Error(`Resource '${MASK_RESOURCE_NAME}' hasn't been loaded.`);\n    }\n    this.tileResource = tileResource;\n    this.maskResource = maskResource;\n\n    this.imageJs = this.makeImageJs();\n    this.canvas = this.imageJs?.getCanvas();\n\n    registry.addEntry(this);\n  }\n\n  public static getTile(type: string, neighborhood: TileNeighborhood): Tile | undefined {\n    return registry.getEntry({ type, neighborhood });\n  }\n\n  public static getOrMakeTile(type: string, neighborhood: TileNeighborhood): Tile {\n    const tile = registry.getEntry({ type, neighborhood });\n    if (tile) {\n      return tile;\n    }\n    return new Tile(type, neighborhood);\n  }\n\n  private makeImageJs(): ImageJs | undefined {\n    const { above, topLeft, topRight, bottomLeft, bottomRight, under } = this.neighborhood;\n    // const { above, topLeft, topRight, bottomLeft, bottomRight, under } = {\n    //   above: false,\n    //   topLeft: false,\n    //   topRight: false,\n    //   bottomLeft: false,\n    //   bottomRight: false,\n    //   under: false,\n    // };\n\n    if (above && bottomLeft && bottomRight) {\n      return;\n    }\n\n    const ressourceImage = this.tileResource.imageJs;\n    const maskImage = this.maskResource.imageJs;\n    // the TS declaration of ImageJs is incorrect: 3rd arg can (and must) be undefined\n    // eslint-disable-next-line\n    // @ts-ignore\n    const tileImage = new ImageJs(32, 24, undefined, {\n      bitDepth: 16,\n    });\n\n    for (let x = 0; x < 32; x++) {\n      for (let y = 0; y < 24; y++) {\n        tileImage.setPixelXY(x, y, [0, 0, 0, 0]);\n        const maskValue = maskImage.getPixelXY(x, y);\n        if (maskValue[0] === MASK.FTL) {\n          if (above === true) {\n            continue;\n          }\n          if (topLeft === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.FTR) {\n          if (above === true) {\n            continue;\n          }\n          if (topRight === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.FBL) {\n          if (above === true) {\n            continue;\n          }\n          if (bottomLeft === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.FBR) {\n          if (above === true) {\n            continue;\n          }\n          if (bottomRight === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.LSL) {\n          if (bottomLeft === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (topLeft === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.LST) {\n          if (bottomLeft === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (above === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.LSB) {\n          if (bottomLeft === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (under === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.LSR) {\n          if (bottomLeft === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (bottomRight === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.RSR) {\n          if (bottomRight === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (topRight === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.RST) {\n          if (bottomRight === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (above === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.RSB) {\n          if (bottomRight === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (under === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n        if (maskValue[0] === MASK.RSL) {\n          if (bottomRight === true) {\n            if (above === true) {\n              continue;\n            }\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n            continue;\n          }\n          if (bottomLeft === false) {\n            tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n            continue;\n          }\n          tileImage.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n          continue;\n        }\n      }\n    }\n\n    return tileImage;\n  }\n}\n","import { Window, Position, CrossSectionPosition } from '../interfaces';\nimport { TileMap } from '../Map';\nimport { Tile, TileNeighborhood } from './Tile';\n\nexport interface Sprite {\n  image: OffscreenCanvas;\n  sx: number;\n  sy: number;\n  sw: number;\n  sh: number;\n}\n\nexport interface PositionedTile {\n  position: Position;\n  crossSectionPosition: CrossSectionPosition;\n  tile: Tile;\n}\n\nexport interface TilesDict {\n  [key: string]: PositionedTile;\n}\n\nexport class CrossSection {\n  public center: Position;\n  public scale: number;\n  public window: Window;\n  public extendedWindow: Window;\n  public heightConstraint: number;\n  public crossSectionConstant: number;\n  private tilesDict: TilesDict;\n  private margin: CrossSectionPosition;\n  public canvas?: OffscreenCanvas;\n  private context?: OffscreenCanvasRenderingContext2D;\n\n  private da = 0;\n  private db = 0;\n  private dw = 0;\n  private dh = 0;\n\n  constructor(\n    public viewConeCenter: Position,\n    public focal: number,\n    public viewConeWindow: Window,\n    public distanceFromCenter: number,\n    public tileMap: TileMap,\n  ) {\n    this.center = {\n      x: viewConeCenter.x - distanceFromCenter / 8,\n      y: viewConeCenter.y - distanceFromCenter / 8,\n      z: viewConeCenter.z - distanceFromCenter / 4,\n    };\n\n    this.scale = 1 + distanceFromCenter / focal;\n\n    this.window = {\n      a1: viewConeWindow.a1 * this.scale,\n      a2: viewConeWindow.a2 * this.scale,\n      b1: viewConeWindow.b1 * this.scale,\n      b2: viewConeWindow.b2 * this.scale,\n    };\n\n    this.margin = { a: 32, b: 24 };\n    this.extendedWindow = {\n      a1: this.window.a1 - this.margin.a,\n      a2: this.window.a2 + this.margin.a,\n      b1: this.window.b1 - this.margin.b,\n      b2: this.window.b2 + this.margin.b,\n    };\n\n    this.heightConstraint = CrossSection.getHeightConstraint(viewConeCenter.z - distanceFromCenter);\n\n    this.crossSectionConstant = this.center.x + this.center.y + this.center.z / 3;\n\n    this.tilesDict = this.makeTilesDict();\n  }\n\n  public get sprite(): Sprite | undefined {\n    if (!this.canvas) {\n      return;\n    }\n    return {\n      image: this.canvas,\n      sx: this.margin.a + this.da + Math.round(this.extendedWidth / 2) - this.extendedWidth / 2,\n      sy: this.margin.b + this.db + Math.round(this.extendedHeight / 2) - this.extendedHeight / 2,\n      sw: this.width + this.dw,\n      sh: this.height + this.dh,\n    };\n  }\n\n  private newCanvasAndContext(): { canvas: OffscreenCanvas; context: OffscreenCanvasRenderingContext2D } {\n    const canvas = new OffscreenCanvas(this.extendedWidth, this.extendedHeight);\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error(`Context cannot be null`);\n    }\n    context.imageSmoothingEnabled = false;\n    return { canvas, context };\n  }\n\n  public paintCanvas(): void {\n    const tiles = this.tiles;\n    if (tiles.length === 0) {\n      return;\n    }\n    if (tiles.every(({ tile }) => !tile.canvas)) {\n      return;\n    }\n\n    if (!this.context) {\n      const { canvas, context } = this.newCanvasAndContext();\n      this.canvas = canvas;\n      this.context = context;\n    }\n    //this.context.globalAlpha = 0.3;\n    tiles.forEach(({ crossSectionPosition: { a, b }, tile }) => {\n      if (!tile.canvas || !this.context) {\n        return;\n      }\n      this.context.drawImage(\n        tile.canvas,\n        Math.round(this.extendedWidth / 2) + (a - 16),\n        Math.round(this.extendedHeight / 2) + (-b - 8),\n        tile.canvas.width,\n        tile.canvas.height,\n      );\n    });\n  }\n\n  public static getHeightConstraint(z: number): number {\n    return (3 + (z % 3)) % 3;\n  }\n\n  public getA({ x, y }: { x: number; y: number }): number {\n    return 16 * (y - this.center.y - (x - this.center.x));\n  }\n  public getB({ z }: { z: number }): number {\n    return (32 / 3) * (z - this.center.z);\n  }\n\n  public getCrossSectionPosition(point: Position): CrossSectionPosition {\n    return {\n      a: this.getA(point),\n      b: this.getB(point),\n    };\n  }\n\n  public getProjetedCrossSectionPosition(point: Position): CrossSectionPosition {\n    return {\n      a: this.getA(point) / this.scale,\n      b: this.getB(point) / this.scale,\n    };\n  }\n\n  public getX({ a, b }: CrossSectionPosition): number {\n    return this.center.x - a / 32 - b / 64;\n  }\n  public getY({ a, b }: CrossSectionPosition): number {\n    return this.center.y + a / 32 - b / 64;\n  }\n  public getZ({ b }: { b: number }): number {\n    return this.center.z + (3 * b) / 32;\n  }\n\n  public getPosition(cpp: CrossSectionPosition): Position {\n    return {\n      x: this.getX(cpp),\n      y: this.getY(cpp),\n      z: this.getZ(cpp),\n    };\n  }\n\n  public forEachTilePosition(cb: (position: Position) => void, zMinBorder?: number, zMaxBorder?: number): void {\n    const { a1, a2, b1, b2 } = this.extendedWindow;\n\n    const k = this.heightConstraint;\n\n    // first integer z in the area\n    let zMin = Math.ceil(this.getZ({ b: b1 }));\n    if (zMinBorder && zMinBorder > zMin) {\n      zMin = zMinBorder;\n    }\n    // first multiple of ki after zMin\n    const k1 = CrossSection.getHeightConstraint(zMin);\n    if (k1 !== k) {\n      zMin = zMin + CrossSection.getHeightConstraint(k - k1);\n    }\n\n    // last integer z in the area\n    let zMax = Math.floor(this.getZ({ b: b2 }));\n    if (zMaxBorder && zMaxBorder < zMax) {\n      zMax = zMaxBorder;\n    }\n    // last multiple of ki before zMax\n    const k2 = CrossSection.getHeightConstraint(zMax);\n    if (k2 !== k) {\n      zMax = zMax - CrossSection.getHeightConstraint(-k + k2);\n    }\n\n    for (let z = zMin; z <= zMax; z += 3) {\n      const b = this.getB({ z });\n      // first integer y in the line z of the area\n      const yMin = Math.ceil(this.getY({ a: a1, b }));\n      // last integer y in the line z of the area\n      const yMax = Math.floor(this.getY({ a: a2, b }));\n      for (let y = yMin; y <= yMax; y++) {\n        const x = Math.round(this.crossSectionConstant - y - z / 3);\n        cb({ x, y, z });\n      }\n    }\n  }\n\n  public get width(): number {\n    return this.window.a2 - this.window.a1;\n  }\n\n  public get height(): number {\n    return this.window.b2 - this.window.b1;\n  }\n  public get extendedWidth(): number {\n    return this.extendedWindow.a2 - this.extendedWindow.a1;\n  }\n\n  public get extendedHeight(): number {\n    return this.extendedWindow.b2 - this.extendedWindow.b1;\n  }\n\n  public get tiles(): PositionedTile[] {\n    return Object.values(this.tilesDict);\n  }\n\n  public static getTileId(position: Position): string {\n    return JSON.stringify(position);\n  }\n\n  public makeTilesDict(): TilesDict {\n    const tilesDict: TilesDict = {};\n    const tileMap = this.tileMap;\n\n    // check if it may be useless to do anything\n    const { a1, a2, b1, b2 } = this.extendedWindow;\n    if (tileMap.crossSectionIsEmpty(this.getPosition({ a: a1, b: b1 }), this.getPosition({ a: a2, b: b2 }))) {\n      return tilesDict;\n    }\n\n    this.forEachTilePosition(\n      (position) => {\n        const value = tileMap.getTileAt(position);\n        if (value) {\n          const neighborhood: TileNeighborhood = {\n            above: tileMap.getTileAt({ ...position, z: position.z + 1 }) === 1,\n            bottomLeft: tileMap.getTileAt({ ...position, x: position.x + 1 }) === 1,\n            bottomRight: tileMap.getTileAt({ ...position, y: position.y + 1 }) === 1,\n            topLeft: tileMap.getTileAt({ ...position, y: position.y - 1 }) === 1,\n            topRight: tileMap.getTileAt({ ...position, x: position.x - 1 }) === 1,\n            under: tileMap.getTileAt({ ...position, z: position.z - 1 }) === 1,\n          };\n          const tile = Tile.getOrMakeTile('tile2', neighborhood);\n          tilesDict[CrossSection.getTileId(position)] = {\n            position,\n            crossSectionPosition: this.getCrossSectionPosition(position),\n            tile,\n          };\n        }\n      },\n      tileMap.borders.zMin,\n      tileMap.borders.zMax,\n    );\n\n    return tilesDict;\n  }\n\n  public move(newViewConeCenter: Position, newFocal: number): void {\n    const k2 = newViewConeCenter.x + newViewConeCenter.y + newViewConeCenter.z / 3;\n    const k1 = this.viewConeCenter.x + this.viewConeCenter.y + this.viewConeCenter.z / 3;\n    const distanceDiff = 3 * (k2 - k1);\n    const newDistanceFromCenter = this.distanceFromCenter + distanceDiff;\n    const newScale = 1 + newDistanceFromCenter / newFocal;\n    const newWindow: Window = {\n      a1: this.viewConeWindow.a1 * newScale,\n      a2: this.viewConeWindow.a2 * newScale,\n      b1: this.viewConeWindow.b1 * newScale,\n      b2: this.viewConeWindow.b2 * newScale,\n    };\n\n    const newExtendedWindow: Window = {\n      a1: newWindow.a1 - this.margin.a,\n      a2: newWindow.a2 + this.margin.a,\n      b1: newWindow.b1 - this.margin.b,\n      b2: newWindow.b2 + this.margin.b,\n    };\n\n    const newExtendedWidth = newExtendedWindow.a2 - newExtendedWindow.a1;\n    const newExtendedHeight = newExtendedWindow.b2 - newExtendedWindow.b1;\n\n    const projetedNewCenter: Position = {\n      x: newViewConeCenter.x - distanceDiff / 8,\n      y: newViewConeCenter.y - distanceDiff / 8,\n      z: newViewConeCenter.z - distanceDiff / 4,\n    };\n\n    const dPosition = {\n      x: this.center.x + this.viewConeCenter.x - projetedNewCenter.x,\n      y: this.center.y + this.viewConeCenter.y - projetedNewCenter.y,\n      z: this.center.z + this.viewConeCenter.z - projetedNewCenter.z,\n    };\n\n    const { a, b } = this.getCrossSectionPosition(dPosition);\n\n    this.da = -(newExtendedWidth / 2 - this.extendedWidth / 2) - a;\n    this.db = -(newExtendedHeight / 2 - this.extendedHeight / 2) + b;\n    this.dw = newWindow.a2 - newWindow.a1 - (this.window.a2 - this.window.a1);\n    this.dh = newWindow.b2 - newWindow.b1 - (this.window.b2 - this.window.b1);\n  }\n}\n"],"sourceRoot":""}