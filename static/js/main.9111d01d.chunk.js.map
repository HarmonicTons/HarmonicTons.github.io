{"version":3,"sources":["Game/getTileImage.ts","Game/Sprite.ts","Game/SpriteRegistry.ts","Game/math.ts","Game/Map.ts","Game/renderer/CrossSection.ts","Game/renderer/ViewCone.ts","Game/index.ts","Stage.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["MASK","Sprite","name","url","dataURL","imageJs","hTMLImageElement","_isLoaded","Error","this","ImageJs","load","toDataURL","img","Image","width","height","src","Promise","r","onload","spriteIsLoaded","sprite","isLoaded","getTileName","neighboors","ressourceSpriteName","JSON","stringify","getTileImage","ressourceSprite","maskSprite","above","topLeft","topRight","bottomLeft","bottomRight","under","ressourceImage","maskImage","tile","undefined","bitDepth","x","y","setPixelXY","maskValue","getPixelXY","FTL","FTR","FBL","FBR","LSL","LST","LSB","LSR","RSR","RST","RSB","RSL","SpriteRegistry","registry","all","Object","values","map","every","toPrecision","n","p","Math","round","TileMap","dict","chunksDicts","chunkSizes","z","getKeyFromPosition","X13","Y13","setChunks","position","key","parse","chunkSize","a","b","c","chunkPosition","floor","getChunkKeyFromChunkPosition","getChunkPosition","keys","forEach","getPositionFromKey","chunksDict","i","getChunkKeyFromPosition","p1","p2","cp1","cp2","length","_crossSectionIsEmpty","CrossSection","viewConeCenter","focal","viewConeWindow","distanceFromCenter","center","scale","window","extendedWindow","heightConstraint","crossSectionConstant","_tilesDict","a1","a2","b1","b2","getHeightConstraint","point","getA","getB","getX","getY","getZ","cb","zMin","zMax","yMin","ceil","yMax","tileMap","crossSectionIsEmpty","getPosition","forEachTilePosition","value","getTileAt","getTileId","crossSectionPosition","getCrossSectionPosition","projetedCrossSectionPosition","getProjetedCrossSectionPosition","tiles","k","k1","k2","ViewCone","startDistanceFromCenter","endDistanceFromCenter","_crossSectionsDict","firstNonEmptyCrossSection","iMax","crossSection","setTilesFromMap","min","crossSections","getEmptyWindows","subWindow","subViewCone","setCrossSectionsFromMap","crossSectionsDict","j","Number","addTilesFromASubCrossSection","_","flatten","cs","minWindowSize","tilesInWindowCSP","t","orderedTiles","orderBy","bottomLeftCorner","A","B1","emptyWindows","addWindow","push","bottomLeftTile","shift","bLine","abs","Game","canvas","spriteRegistry","addSprite","ctx","getContext","imageSmoothingEnabled","x0","y0","ratio","margin","console","time","viewCone","timeEnd","buffer","index","tileSprite","getSprite","screenPosition","size","s","drawImage","beginPath","rect","stroke","Stage","canvasEl","useRef","useEffect","current","start","ref","style","border","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.9111d01d.chunk.js","sourcesContent":["import { Image as ImageJs } from 'image-js';\nimport { LoadedSprite, Sprite } from './Sprite';\n\nenum MASK {\n  FTL = 64329,\n  LSL = 63735,\n  LSB = 10280,\n  LST = 62509,\n  FBL = 65277,\n  LSR = 57567,\n  FTR = 53199,\n  FBR = 0,\n  RSL = 59623,\n  RSB = 27296,\n  RST = 16824,\n  RSR = 61807,\n}\n\nexport type Neighboors = {\n  above: boolean;\n  topLeft: boolean;\n  topRight: boolean;\n  bottomLeft: boolean;\n  bottomRight: boolean;\n  under: boolean;\n};\n\nexport const getTileName = ({\n  neighboors,\n  ressourceSpriteName,\n}: {\n  neighboors: Neighboors;\n  ressourceSpriteName: string;\n}): string => {\n  return ressourceSpriteName + '-' + JSON.stringify(neighboors);\n};\n\nexport const getTileImage = ({\n  neighboors,\n  ressourceSprite,\n  maskSprite,\n}: {\n  neighboors: Neighboors;\n  ressourceSprite: LoadedSprite;\n  maskSprite: LoadedSprite;\n}): Sprite => {\n  const { above, topLeft, topRight, bottomLeft, bottomRight, under } = neighboors;\n  // const { above, topLeft, topRight, bottomLeft, bottomRight, under } = {\n  //   above: false,\n  //   topLeft: false,\n  //   topRight: false,\n  //   bottomLeft: false,\n  //   bottomRight: false,\n  //   under: false,\n  // };\n  const ressourceImage = ressourceSprite.imageJs;\n  const maskImage = maskSprite.imageJs;\n  // the TS declaration of ImageJs is incorrect: 3rd arg can (and must) be undefined\n  // eslint-disable-next-line\n    // @ts-ignore\n  const tile = new ImageJs(32, 24, undefined, {\n    bitDepth: 16,\n  });\n\n  for (let x = 0; x < 32; x++) {\n    for (let y = 0; y < 24; y++) {\n      tile.setPixelXY(x, y, [0, 0, 0, 0]);\n      const maskValue = maskImage.getPixelXY(x, y);\n      if (maskValue[0] === MASK.FTL) {\n        if (above === true) {\n          continue;\n        }\n        if (topLeft === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.FTR) {\n        if (above === true) {\n          continue;\n        }\n        if (topRight === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.FBL) {\n        if (above === true) {\n          continue;\n        }\n        if (bottomLeft === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.FBR) {\n        if (above === true) {\n          continue;\n        }\n        if (bottomRight === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.LSL) {\n        if (bottomLeft === true) {\n          if (above === true) {\n            continue;\n          }\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (topLeft === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.LST) {\n        if (bottomLeft === true) {\n          if (above === true) {\n            continue;\n          }\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (above === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.LSB) {\n        if (bottomLeft === true) {\n          if (above === true) {\n            continue;\n          }\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (under === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.LSR) {\n        if (bottomLeft === true) {\n          if (above === true) {\n            continue;\n          }\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (bottomRight === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.RSR) {\n        if (bottomRight === true) {\n          if (above === true) {\n            continue;\n          }\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (topRight === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.RST) {\n        if (bottomRight === true) {\n          if (above === true) {\n            continue;\n          }\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (above === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.RSB) {\n        if (bottomRight === true) {\n          if (above === true) {\n            continue;\n          }\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (under === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n        continue;\n      }\n      if (maskValue[0] === MASK.RSL) {\n        if (bottomRight === true) {\n          if (above === true) {\n            continue;\n          }\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 24)]);\n          continue;\n        }\n        if (bottomLeft === false) {\n          tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y)]);\n          continue;\n        }\n        tile.setPixelXY(x, y, [...ressourceImage.getPixelXY(x, y + 48)]);\n        continue;\n      }\n    }\n  }\n\n  return new Sprite({ name: getTileName({ neighboors, ressourceSpriteName: ressourceSprite.name }), imageJs: tile });\n};\n","import { Image as ImageJs } from 'image-js';\n\nexport class Sprite {\n  public name: string;\n  public url?: string;\n  public dataURL?: string;\n  public imageJs?: ImageJs;\n  public hTMLImageElement?: HTMLImageElement;\n  public _isLoaded: boolean;\n\n  constructor({\n    name,\n    url,\n    dataURL,\n    imageJs,\n    hTMLImageElement,\n  }: {\n    name: string;\n    url?: string;\n    dataURL?: string;\n    imageJs?: ImageJs;\n    hTMLImageElement?: HTMLImageElement;\n  }) {\n    if (!url && !dataURL && !imageJs && !hTMLImageElement) {\n      throw new Error('Must at least specify one source for the image');\n    }\n    this.name = name;\n    this.url = url;\n    this.dataURL = dataURL;\n    this.imageJs = imageJs;\n    this.hTMLImageElement = hTMLImageElement;\n    this._isLoaded = false;\n  }\n\n  get isLoaded(): boolean {\n    return this._isLoaded;\n  }\n\n  public async load(): Promise<void> {\n    if (this._isLoaded) {\n      return;\n    }\n    if (this.url && !this.imageJs) {\n      this.imageJs = await ImageJs.load(this.url);\n    }\n    if (this.imageJs && !this.dataURL) {\n      this.dataURL = this.imageJs.toDataURL();\n    }\n    if (this.dataURL && !this.imageJs) {\n      this.imageJs = await ImageJs.load(this.dataURL);\n    }\n    if (this.dataURL && this.imageJs && !this.hTMLImageElement) {\n      const img = new Image(this.imageJs.width, this.imageJs.height);\n      img.src = this.dataURL;\n      await new Promise((r) => (img.onload = () => r()));\n      this.hTMLImageElement = img;\n    }\n    this._isLoaded = true;\n  }\n}\nexport interface LoadedSprite extends Sprite {\n  dataURL: string;\n  imageJs: ImageJs;\n  hTMLImageElement: HTMLImageElement;\n  isLoaded: true;\n}\n\nexport const spriteIsLoaded = (sprite: Sprite): sprite is LoadedSprite => {\n  return sprite.isLoaded;\n};\n","import { Sprite } from './Sprite';\n\nexport class SpriteRegistry {\n  private registry: {\n    [name: string]: Sprite;\n  };\n\n  constructor() {\n    this.registry = {};\n  }\n\n  public addSprite(sprite: Sprite): void {\n    if (this.registry[sprite.name]) {\n      throw new Error(`A sprite named '${sprite.name}' is already present in registry.`);\n    }\n    this.registry[sprite.name] = sprite;\n  }\n\n  public getSprite(name: string): Sprite {\n    return this.registry[name];\n  }\n\n  public get isLoaded(): boolean {\n    return Object.values(this.registry).every((sprite) => sprite.isLoaded);\n  }\n\n  public async load(): Promise<void> {\n    if (this.isLoaded) {\n      return;\n    }\n    await Promise.all(Object.values(this.registry).map((sprite) => sprite.load()));\n  }\n}\n","export const toPrecision = (n: number, p = 3): number => {\n  return Math.round(n * 10 ** p) / 10 ** p;\n};\n","import { Position } from './interfaces';\nimport { toPrecision as p } from './math';\n\ninterface ChunkPosition {\n  a: number;\n  b: number;\n  c: number;\n}\n\nexport class TileMap {\n  private dict: {\n    [key: string]: number;\n  } = {};\n  private chunksDicts: {\n    [key: string]: boolean;\n  }[];\n  private chunkSizes = [40, 20, 10, 5];\n  constructor() {\n    // TODO load from JSON\n\n    this.chunksDicts = this.chunkSizes.map(() => ({}));\n\n    const X01 = -2;\n    const Y01 = -2;\n    const X11 = 2;\n    const Y11 = 2;\n    const Z0 = -100;\n    const Z1 = 0;\n\n    for (let z = Z0; z <= Z1; z++) {\n      for (let x = X01; x <= X11; x++) {\n        for (let y = Y01; y <= Y11; y++) {\n          this.dict[this.getKeyFromPosition({ x, y, z })] = 1;\n        }\n      }\n    }\n\n    const X02 = -100;\n    const Y02 = -100;\n    const X12 = 100;\n    const Y12 = 100;\n    const Z2 = -100;\n\n    for (let x = X02; x <= X12; x++) {\n      for (let y = Y02; y <= Y12; y++) {\n        if ((x + y) % 2 === -1) {\n          //continue;\n        }\n        this.dict[this.getKeyFromPosition({ x, y, z: Z2 })] = 1;\n      }\n    }\n\n    const i = 50;\n    const X03 = -4 + i;\n    const Y03 = 0 + i;\n    const X13 = 0 + i;\n    const Y13 = 4 + i;\n\n    for (let x = X03; x <= X13; x++) {\n      for (let y = Y03; y <= Y13; y++) {\n        this.dict[this.getKeyFromPosition({ x, y, z: 2 * i })] = 1;\n      }\n    }\n    this.dict[this.getKeyFromPosition({ x: X13 - 1, y: Y13 + 1, z: 2 * i })] = 1;\n    this.dict[this.getKeyFromPosition({ x: X13 - 3, y: Y13 + 1, z: 2 * i })] = 1;\n    this.dict[this.getKeyFromPosition({ x: X13 - 1, y: Y13 + 2, z: 2 * i })] = 1;\n    this.dict[this.getKeyFromPosition({ x: X13 - 3, y: Y13 + 2, z: 2 * i })] = 1;\n    this.dict[this.getKeyFromPosition({ x: X13 - 2, y: Y13 + 2, z: 2 * i })] = 1;\n\n    this.setChunks();\n  }\n\n  private getKeyFromPosition(position: Position): string {\n    return JSON.stringify(position);\n  }\n\n  private getPositionFromKey(key: string): Position {\n    return JSON.parse(key);\n  }\n\n  private getChunkPosition(chunkSize: number, position: Position): ChunkPosition {\n    return {\n      a: p((position.y - position.x) / chunkSize),\n      b: p((position.y + position.x + position.z / 3) / chunkSize),\n      c: p(position.z / chunkSize),\n    };\n  }\n\n  private getChunkKeyFromChunkPosition(chunkPosition: ChunkPosition): string {\n    return JSON.stringify({\n      a: Math.floor(chunkPosition.a),\n      b: Math.floor(chunkPosition.b),\n      c: Math.floor(chunkPosition.c),\n    });\n  }\n\n  private getChunkKeyFromPosition(chunkSize: number, position: Position): string {\n    return this.getChunkKeyFromChunkPosition(this.getChunkPosition(chunkSize, position));\n  }\n\n  public getTileAt(position: Position): number {\n    return this.dict[this.getKeyFromPosition(position)];\n  }\n\n  public setChunks(): void {\n    Object.keys(this.dict).forEach((key) => {\n      const position = this.getPositionFromKey(key);\n      this.chunksDicts.forEach((chunksDict, i) => {\n        chunksDict[this.getChunkKeyFromPosition(this.chunkSizes[i], position)] = true;\n      });\n    });\n  }\n\n  public _crossSectionIsEmpty(chunksDict: any, chunkSize: number, p1: Position, p2: Position): boolean {\n    const cp1 = this.getChunkPosition(chunkSize, p1);\n    const cp2 = this.getChunkPosition(chunkSize, p2);\n    for (let a = Math.floor(cp1.a); a <= cp2.a; a++) {\n      for (let c = Math.floor(cp1.c); c <= cp2.c; c++) {\n        if (chunksDict[this.getChunkKeyFromChunkPosition({ a, b: cp1.b, c })]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  public crossSectionIsEmpty(p1: Position, p2: Position): boolean {\n    for (let i = 0; i < this.chunksDicts.length; i++) {\n      if (this._crossSectionIsEmpty(this.chunksDicts[i], this.chunkSizes[i], p1, p2) === true) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","import { Window, Position, Tile, CrossSectionPosition } from '../interfaces';\nimport { TileMap } from '../Map';\n\nexport class CrossSection {\n  public center: Position;\n  public scale: number;\n  public window: Window;\n  public extendedWindow: Window;\n  public heightConstraint: number;\n  public crossSectionConstant: number;\n  private _tilesDict: { [key: string]: Tile } = {};\n\n  constructor(\n    public viewConeCenter: Position,\n    public focal: number,\n    public viewConeWindow: Window,\n    public distanceFromCenter: number,\n  ) {\n    this.center = {\n      x: viewConeCenter.x - distanceFromCenter / 8,\n      y: viewConeCenter.y - distanceFromCenter / 8,\n      z: viewConeCenter.z - distanceFromCenter / 4,\n    };\n\n    this.scale = 1 + distanceFromCenter / focal;\n\n    this.window = {\n      a1: viewConeWindow.a1 * this.scale,\n      a2: viewConeWindow.a2 * this.scale,\n      b1: viewConeWindow.b1 * this.scale,\n      b2: viewConeWindow.b2 * this.scale,\n    };\n\n    const margin = 2 - 0.001; // -0.001 to be juuuust under half a tile\n    const marginBottom = 1 - 0.001;\n    this.extendedWindow = {\n      a1: this.window.a1 - margin,\n      a2: this.window.a2 + margin,\n      b1: this.window.b1 - marginBottom,\n      b2: this.window.b2 + margin,\n    };\n\n    this.heightConstraint = CrossSection.getHeightConstraint(viewConeCenter.z - distanceFromCenter);\n\n    this.crossSectionConstant = this.center.x + this.center.y + this.center.z / 3;\n  }\n\n  public static getHeightConstraint(z: number): number {\n    return (3 + (z % 3)) % 3;\n  }\n\n  public getA({ y, z }: { y: number; z: number }): number {\n    return 4 * (y - this.center.y + (z - this.center.z) / 6);\n  }\n  public getB(z: number): number {\n    return (4 / 3) * (z - this.center.z);\n  }\n\n  public getCrossSectionPosition(point: Position): CrossSectionPosition {\n    return {\n      a: this.getA(point),\n      b: this.getB(point.z),\n    };\n  }\n\n  public getProjetedCrossSectionPosition(point: Position): CrossSectionPosition {\n    return {\n      a: this.getA(point) / this.scale,\n      b: this.getB(point.z) / this.scale,\n    };\n  }\n\n  public getX({ a, b }: CrossSectionPosition): number {\n    return this.center.x - a / 4 - b / 8;\n  }\n  public getY({ a, b }: CrossSectionPosition): number {\n    return this.center.y + a / 4 - b / 8;\n  }\n  public getZ(b: number): number {\n    return this.center.z + (3 * b) / 4;\n  }\n\n  public getPosition({ a, b }: CrossSectionPosition): Position {\n    return {\n      x: this.getX({ a, b }),\n      y: this.getY({ a, b }),\n      z: this.getZ(b),\n    };\n  }\n\n  public get zMin(): number {\n    const { b1 } = this.extendedWindow;\n    const k = this.heightConstraint;\n\n    // first integer z in the area\n    let zMin = Math.ceil(this.getZ(b1));\n    // first multiple of ki after zMin\n    const k1 = CrossSection.getHeightConstraint(zMin);\n    if (k1 !== k) {\n      zMin = zMin + CrossSection.getHeightConstraint(k - k1);\n    }\n    return zMin;\n  }\n\n  public get zMax(): number {\n    const { b2 } = this.extendedWindow;\n    const k = this.heightConstraint;\n\n    // last integer z in the area\n    let zMax = Math.floor(this.getZ(b2));\n    // last multiple of ki before zMax\n    const k2 = CrossSection.getHeightConstraint(zMax);\n    if (k2 !== k) {\n      zMax = zMax - CrossSection.getHeightConstraint(-k + k2);\n    }\n    return zMax;\n  }\n\n  public forEachTilePosition(cb: (position: Position) => void): void {\n    const { a1, a2 } = this.extendedWindow;\n\n    for (let z = this.zMin; z <= this.zMax; z += 3) {\n      const b = this.getB(z);\n      // first integer y in the line z of the area\n      const yMin = Math.ceil(this.getY({ a: a1, b }));\n      // last integer y in the line z of the area\n      const yMax = Math.floor(this.getY({ a: a2, b }));\n      for (let y = yMin; y <= yMax; y++) {\n        const x = Math.round(this.crossSectionConstant - y - z / 3);\n        cb({ x, y, z });\n      }\n    }\n  }\n\n  get tiles(): Tile[] {\n    return Object.values(this._tilesDict);\n  }\n\n  public static getTileId(position: Position): string {\n    return JSON.stringify(position);\n  }\n\n  public setTilesFromMap(tileMap: TileMap): Tile[] {\n    this._tilesDict = {};\n\n    // check if it may be useless to do anything\n    const { a1, a2, b1, b2 } = this.extendedWindow;\n    if (tileMap.crossSectionIsEmpty(this.getPosition({ a: a1, b: b1 }), this.getPosition({ a: a2, b: b2 }))) {\n      return this.tiles;\n    }\n\n    this.forEachTilePosition((position) => {\n      const value = tileMap.getTileAt(position);\n      if (value) {\n        this._tilesDict[CrossSection.getTileId(position)] = {\n          position,\n          crossSectionPosition: this.getCrossSectionPosition(position),\n          projetedCrossSectionPosition: this.getProjetedCrossSectionPosition(position),\n          scale: 1 / this.scale,\n          value,\n        };\n      }\n    });\n    return this.tiles;\n  }\n\n  public addTilesFromASubCrossSection(tiles: Tile[]): void {\n    tiles.forEach((tile) => {\n      this._tilesDict[CrossSection.getTileId(tile.position)] = {\n        ...tile,\n        crossSectionPosition: this.getCrossSectionPosition(tile.position),\n        projetedCrossSectionPosition: this.getProjetedCrossSectionPosition(tile.position),\n      };\n    });\n  }\n}\n","import { Window, Position, CrossSectionPosition } from '../interfaces';\nimport { CrossSection } from './CrossSection';\nimport { TileMap } from '../Map';\nimport _ from 'lodash';\nimport { toPrecision as p } from '../math';\n\nexport class ViewCone {\n  public _crossSectionsDict: { [key: number]: CrossSection } = {};\n  constructor(\n    public center: Position,\n    public focal: number,\n    public window: Window,\n    public startDistanceFromCenter: number,\n    public endDistanceFromCenter: number,\n  ) {}\n\n  get crossSectionsDict(): { [key: number]: CrossSection } {\n    return this._crossSectionsDict;\n  }\n\n  get crossSections(): CrossSection[] {\n    return Object.values(this._crossSectionsDict);\n  }\n\n  setCrossSectionsFromMap(tileMap: TileMap): CrossSection[] {\n    this._crossSectionsDict = {};\n    let i = 0;\n    let iMax = this.endDistanceFromCenter - this.startDistanceFromCenter;\n    let firstNonEmptyCrossSection: CrossSection | undefined;\n    while (i <= iMax) {\n      const crossSection = new CrossSection(this.center, this.focal, this.window, this.startDistanceFromCenter + i);\n      this._crossSectionsDict[this.startDistanceFromCenter + i] = crossSection;\n      const tilesInCrossSection = crossSection.setTilesFromMap(tileMap);\n      if (tilesInCrossSection.length > 0) {\n        iMax = Math.min(iMax, i + 3);\n        if (!firstNonEmptyCrossSection) {\n          firstNonEmptyCrossSection = crossSection;\n        }\n      }\n      i++;\n    }\n\n    if (this.startDistanceFromCenter + i - 1 >= this.endDistanceFromCenter) {\n      return this.crossSections;\n    }\n\n    if (!firstNonEmptyCrossSection) {\n      throw new Error('First non empty cross section cannot be undefined here');\n    }\n\n    //console.time('getEmptyWindows');\n    const subWindows = this.getEmptyWindows(firstNonEmptyCrossSection);\n    //console.timeEnd('getEmptyWindows');\n    subWindows.forEach((subWindow) => {\n      const subViewCone = new ViewCone(\n        this.center,\n        this.focal,\n        subWindow,\n        this.startDistanceFromCenter + i,\n        this.endDistanceFromCenter,\n      );\n      subViewCone.setCrossSectionsFromMap(tileMap);\n      Object.keys(subViewCone.crossSectionsDict).forEach((j) => {\n        const distanceFromCenter = Number(j);\n        if (!this.crossSectionsDict[distanceFromCenter]) {\n          this.crossSectionsDict[distanceFromCenter] = new CrossSection(\n            this.center,\n            this.focal,\n            this.window,\n            distanceFromCenter,\n          );\n        }\n        this.crossSectionsDict[distanceFromCenter].addTilesFromASubCrossSection(\n          subViewCone.crossSectionsDict[distanceFromCenter].tiles,\n        );\n      });\n    });\n    return this.crossSections;\n  }\n\n  public getEmptyWindows(firstNonEmptyCrossSection: CrossSection): Window[] {\n    const scale = p(1 / firstNonEmptyCrossSection.scale);\n    const tiles = _.flatten(this.crossSections.map((cs) => cs.tiles));\n    const minWindowSize = p(0.1 * scale);\n    const window = this.window;\n    const tilesInWindowCSP = tiles.map((t) => t.projetedCrossSectionPosition);\n    const orderedTiles = _.orderBy(tilesInWindowCSP, ['b', 'a'], ['asc', 'asc']);\n\n    const bottomLeftCorner: CrossSectionPosition = {\n      a: p(window.a1),\n      b: p(window.b1),\n    };\n\n    const A = p(2 * scale);\n    const B1 = p(1 * scale);\n    const B2 = 0;\n\n    const emptyWindows: Window[] = [];\n    const addWindow = (window: Window): void => {\n      if (p(window.a2 - window.a1) <= minWindowSize || p(window.b2 - window.b1) <= minWindowSize) {\n        return;\n      }\n      emptyWindows.push(window);\n    };\n    while (bottomLeftCorner.b < window.b2) {\n      let bottomLeftTile: CrossSectionPosition | undefined = orderedTiles[0];\n\n      // no more tiles\n      if (!bottomLeftTile) {\n        addWindow({\n          a1: bottomLeftCorner.a,\n          a2: window.a2,\n          b1: bottomLeftCorner.b,\n          b2: window.b2,\n        });\n        break;\n      }\n\n      // the tile is behind the corner\n      if (p(bottomLeftCorner.a - bottomLeftTile.a) >= A || p(bottomLeftCorner.b - bottomLeftTile.b) >= B2) {\n        orderedTiles.shift();\n        continue;\n      }\n\n      // the tile is not on the same line\n      if (p(bottomLeftTile.b - bottomLeftCorner.b) > B1) {\n        // complete empty line\n        const b2 = Math.min(window.b2, p(bottomLeftTile.b - B1));\n        addWindow({\n          a1: bottomLeftCorner.a,\n          a2: window.a2,\n          b1: bottomLeftCorner.b,\n          b2,\n        });\n        bottomLeftCorner.b = b2;\n        continue;\n      }\n\n      // the tile is on the same line\n      const bLine = bottomLeftTile.b;\n      const b2 = Math.min(window.b2, p(bLine + B2));\n      while (bottomLeftCorner.a < window.a2) {\n        bottomLeftTile = orderedTiles[0];\n\n        // no more tile on the same line or at all\n        if (!bottomLeftTile || bottomLeftTile.b !== bLine) {\n          addWindow({\n            a1: bottomLeftCorner.a,\n            a2: window.a2,\n            b1: bottomLeftCorner.b,\n            b2,\n          });\n          break;\n        }\n\n        // the tile is behind the corner\n        if (p(bottomLeftCorner.a - bottomLeftTile.a) >= A || p(bottomLeftCorner.b - bottomLeftTile.b) >= B2) {\n          orderedTiles.shift();\n          continue;\n        }\n\n        // in the tile\n        if (Math.abs(p(bottomLeftTile.a - bottomLeftCorner.a)) <= A) {\n          // remove bottomLeftTile\n          orderedTiles.shift();\n          bottomLeftCorner.a = Math.min(window.a2, p(bottomLeftTile.a + A));\n          continue;\n        }\n\n        // tile on the same line further\n        const a2 = Math.min(window.a2, p(bottomLeftTile.a - A));\n        addWindow({\n          a1: bottomLeftCorner.a,\n          a2,\n          b1: bottomLeftCorner.b,\n          b2,\n        });\n        // remove bottomLeftTile\n        orderedTiles.shift();\n        bottomLeftCorner.a = p(a2 + 2 * A);\n        continue;\n      }\n\n      // reset line position\n      bottomLeftCorner.a = window.a1;\n      bottomLeftCorner.b = b2;\n    }\n\n    return emptyWindows;\n  }\n}\n","import { getTileImage, Neighboors, getTileName } from './getTileImage';\nimport { SpriteRegistry } from './SpriteRegistry';\nimport { Sprite, spriteIsLoaded } from './Sprite';\nimport { TileMap } from './Map';\nimport { Window, Position } from './interfaces';\nimport { ViewCone } from './renderer/ViewCone';\nimport * as _ from 'lodash';\n\nexport class Game {\n  constructor(private readonly canvas: any) {}\n\n  async start(): Promise<void> {\n    const spriteRegistry = new SpriteRegistry();\n\n    const ressourceSprite = new Sprite({ name: 'tile1', url: process.env.PUBLIC_URL + '/tile2.png' });\n    const maskSprite = new Sprite({ name: 'mask', url: process.env.PUBLIC_URL + '/mask.png' });\n\n    spriteRegistry.addSprite(ressourceSprite);\n    spriteRegistry.addSprite(maskSprite);\n\n    const ctx = this.canvas.getContext('2d');\n    ctx.imageSmoothingEnabled = false;\n\n    await spriteRegistry.load();\n\n    if (!spriteIsLoaded(ressourceSprite) || !spriteIsLoaded(maskSprite)) {\n      throw new Error('load failed');\n    }\n\n    const x0 = Math.floor(this.canvas.width / 2);\n    const y0 = Math.floor(this.canvas.height / 2);\n\n    const ratio = 16;\n\n    const getA = (x: number): number => (x - x0) / ratio + 2;\n    const getB = (y: number): number => -(y - y0) / ratio - 1;\n\n    // get tiles visible from map\n    const map = new TileMap();\n    const center: Position = { x: -2, y: -2, z: 0 };\n    const margin = 0;\n    const window: Window = {\n      a1: getA(-2 * ratio + margin),\n      a2: getA(-2 * ratio + this.canvas.width - margin),\n      b1: getB(-ratio + this.canvas.height - margin),\n      b2: getB(-ratio + margin),\n    };\n\n    console.time('viewcone');\n    const viewCone = new ViewCone(center, 1000, window, -900, 1000);\n    viewCone.setCrossSectionsFromMap(map);\n    console.timeEnd('viewcone');\n    const crossSections = _.orderBy(viewCone.crossSections, ['distanceFromCenter'], ['asc']);\n    const tiles = _.flatten(crossSections.map((cs) => cs.tiles));\n\n    interface PositionedSprite {\n      sprite: Sprite;\n      screenPosition: { x: number; y: number };\n      size: number;\n    }\n\n    console.time('buffering');\n    const buffer: PositionedSprite[] = [];\n    for (let index = tiles.length - 1; index >= 0; index--) {\n      const tile = tiles[index];\n      const neighboors: Neighboors = {\n        above: map.getTileAt({ ...tile.position, z: tile.position.z + 1 }) === 1,\n        bottomLeft: map.getTileAt({ ...tile.position, x: tile.position.x + 1 }) === 1,\n        bottomRight: map.getTileAt({ ...tile.position, y: tile.position.y + 1 }) === 1,\n        topLeft: map.getTileAt({ ...tile.position, y: tile.position.y - 1 }) === 1,\n        topRight: map.getTileAt({ ...tile.position, x: tile.position.x - 1 }) === 1,\n        under: map.getTileAt({ ...tile.position, z: tile.position.z - 1 }) === 1,\n      };\n      let tileSprite = spriteRegistry.getSprite(getTileName({ neighboors, ressourceSpriteName: ressourceSprite.name }));\n      if (!tileSprite) {\n        tileSprite = getTileImage({\n          neighboors,\n          ressourceSprite,\n          maskSprite,\n        });\n        spriteRegistry.addSprite(tileSprite);\n      }\n\n      buffer.push({\n        sprite: tileSprite,\n        screenPosition: {\n          x: x0 + (tile.projetedCrossSectionPosition.a - 2) * ratio + 2 * ratio * (1 - tile.scale),\n          y: y0 - (tile.projetedCrossSectionPosition.b + 1) * ratio + ratio * (1 - tile.scale),\n        },\n        size: tile.scale,\n      });\n    }\n\n    console.timeEnd('buffering');\n\n    console.time('loading');\n    if (!spriteRegistry.isLoaded) {\n      await spriteRegistry.load();\n    }\n\n    console.timeEnd('loading');\n\n    console.time('drawing');\n    buffer.forEach((s) => {\n      //ctx.globalAlpha = 0.3;\n      ctx.drawImage(\n        s.sprite.hTMLImageElement,\n        0,\n        0,\n        32,\n        24,\n        s.screenPosition.x,\n        s.screenPosition.y,\n        4 * ratio * s.size,\n        3 * ratio * s.size,\n      );\n    });\n\n    console.timeEnd('drawing');\n\n    ctx.beginPath();\n    ctx.rect(margin, margin, this.canvas.width - 2 * margin, this.canvas.height - 2 * margin);\n    ctx.stroke();\n  }\n}\n","import React, { useRef, useEffect } from 'react';\nimport { Game } from './Game';\n\nconst Stage = (): JSX.Element => {\n  const canvasEl = useRef(null);\n  useEffect(() => {\n    if (!canvasEl || !canvasEl.current) {\n      return;\n    }\n    const game = new Game(canvasEl.current);\n    game.start();\n  }, [canvasEl]);\n\n  return (\n    <>\n      <canvas\n        width={1600}\n        height={800}\n        ref={canvasEl}\n        style={{\n          border: '1px solid black',\n          margin: '20px',\n        }}\n      />\n    </>\n  );\n};\n\nexport default Stage;\n","import React from 'react';\nimport Stage from './Stage';\n\nconst App = (): JSX.Element => {\n  return (\n    <div>\n      <p>IME</p>\n      <Stage />\n    </div>\n  );\n};\n\nexport default App;\n","/* eslint-disable */\n\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}